
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Tls - Node.js 4 LTS - W3cubDocs</title>
  
  <meta name="description" content=" Use require(&#39;tls&#39;) to access this module. ">
  <meta name="keywords" content="tls, ssl, -, node, js, lts, node~4_lts">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/node~4_lts/tls/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/node~4_lts.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/node~4_lts/" class="_nav-link" title="" style="margin-left:0;">Node.js 4 LTS</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _node">
				
				
<h1 id="tls_tls_ssl">TLS (SSL)</h1> <div class="api_stability api_stability_2">Stability: 2 - Stable</div>
<p>Use <code>require('tls')</code> to access this module.</p> <p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or Secure Socket Layer: encrypted stream communication.</p> <p>TLS/SSL is a public/private key infrastructure. Each client and each server must have a private key. A private key is created like this:</p> <pre>openssl genrsa -out ryans-key.pem 2048
</pre>
<p>All servers and some clients need to have a certificate. Certificates are public keys signed by a Certificate Authority or self-signed. The first step to getting a certificate is to create a "Certificate Signing Request" (CSR) file. This is done with:</p> <pre>openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem
</pre>
<p>To create a self-signed certificate with the CSR, do this:</p> <pre>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem
</pre>
<p>Alternatively you can send the CSR to a Certificate Authority for signing.</p> <p>For Perfect Forward Secrecy, it is required to generate Diffie-Hellman parameters:</p> <pre>openssl dhparam -outform PEM -out dhparam.pem 2048
</pre>
<p>To create .pfx or .p12, do this:</p> <pre>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
      -certfile ca-cert.pem -out agent5.pfx
</pre>
<ul> <li>
<code>in</code>: certificate</li> <li>
<code>inkey</code>: private key</li> <li>
<code>certfile</code>: all CA certs concatenated in one file like <code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code>
</li> </ul> <h2 id="tls_client_initiated_renegotiation_attack_mitigation">Client-initiated renegotiation attack mitigation</h2>  <p>The TLS protocol lets the client renegotiate certain aspects of the TLS session. Unfortunately, session renegotiation requires a disproportional amount of server-side resources, which makes it a potential vector for denial-of-service attacks.</p> <p>To mitigate this, renegotiations are limited to three times every 10 minutes. An error is emitted on the <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> instance when the threshold is exceeded. The limits are configurable:</p> <ul> <li>
<p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p> </li> <li>
<p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is 10 minutes.</p> </li> </ul> <p>Don't change the defaults unless you know what you are doing.</p> <p>To test your server, connect to it with <code>openssl s_client -connect address:port</code> and tap <code>R&lt;CR&gt;</code> (that's the letter <code>R</code> followed by a carriage return) a few times.</p> <h2 id="tls_modifying_the_default_tls_cipher_suite">Modifying the Default TLS Cipher suite</h2> <p>Node.js is built with a default suite of enabled and disabled TLS ciphers. Currently, the default cipher suite is:</p> <pre>ECDHE-RSA-AES128-GCM-SHA256:
ECDHE-ECDSA-AES128-GCM-SHA256:
ECDHE-RSA-AES256-GCM-SHA384:
ECDHE-ECDSA-AES256-GCM-SHA384:
DHE-RSA-AES128-GCM-SHA256:
ECDHE-RSA-AES128-SHA256:
DHE-RSA-AES128-SHA256:
ECDHE-RSA-AES256-SHA384:
DHE-RSA-AES256-SHA384:
ECDHE-RSA-AES256-SHA256:
DHE-RSA-AES256-SHA256:
HIGH:
!aNULL:
!eNULL:
!EXPORT:
!DES:
!RC4:
!MD5:
!PSK:
!SRP:
!CAMELLIA
</pre>
<p>This default can be overriden entirely using the <code>--tls-cipher-list</code> command line switch. For instance, the following makes <code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> the default TLS cipher suite:</p> <pre>node --tls-cipher-list="ECDHE-RSA-AES128-GCM-SHA256:!RC4"
</pre>
<p>Note that the default cipher suite included within Node.js has been carefully selected to reflect current security best practices and risk mitigation. Changing the default cipher suite can have a significant impact on the security of an application. The <code>--tls-cipher-list</code> switch should by used only if absolutely necessary.</p> <h2 id="tls_alpn_npn_and_sni">ALPN, NPN and SNI</h2>  <p>ALPN (Application-Layer Protocol Negotiation Extension), NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS handshake extensions allowing you:</p> <ul> <li>ALPN/NPN - to use one TLS server for multiple protocols (HTTP, SPDY, HTTP/2)</li> <li>SNI - to use one TLS server for multiple hostnames with different SSL certificates.</li> </ul> <h2 id="tls_perfect_forward_secrecy">Perfect Forward Secrecy</h2>  <p>The term "<a href="https://en.wikipedia.org/wiki/Perfect_forward_secrecy" target="_blank">Forward Secrecy</a>" or "Perfect Forward Secrecy" describes a feature of key-agreement (i.e. key-exchange) methods. Practically it means that even if the private key of a (your) server is compromised, communication can only be decrypted by eavesdroppers if they manage to obtain the key-pair specifically generated for each session.</p> <p>This is achieved by randomly generating a key pair for key-agreement on every handshake (in contrary to the same key for all sessions). Methods implementing this technique, thus offering Perfect Forward Secrecy, are called "ephemeral".</p> <p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note the character "E" appended to the traditional abbreviations):</p> <ul> <li>
<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank">DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li> <li>
<a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" target="_blank">ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman key-agreement protocol.</li> </ul> <p>Ephemeral methods may have some performance drawbacks, because key generation is expensive.</p> <h2 id="tls_class_cryptostream">Class: CryptoStream</h2> <div class="api_stability api_stability_0">Stability: 0 - Deprecated: Use <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> instead.</div>
<p>This is an encrypted stream.</p> <h3 id="tls_cryptostream_byteswritten">cryptoStream.bytesWritten</h3> <p>A proxy to the underlying socket's bytesWritten accessor, this will return the total bytes written to the socket, <em>including the TLS overhead</em>.</p> <h2 id="tls_class_securepair">Class: SecurePair</h2> <p>Returned by tls.createSecurePair.</p> <h3 id="tls_event_secure">Event: 'secure'</h3> <p>The event is emitted from the SecurePair once the pair has successfully established a secure connection.</p> <p>Similarly to the checking for the server <code>'secureConnection'</code> event, pair.cleartext.authorized should be checked to confirm whether the certificate used properly authorized.</p> <h2 id="tls_class_tls_server">Class: tls.Server</h2> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p>This class is a subclass of <code>net.Server</code> and has the same methods on it. Instead of accepting just raw TCP connections, this accepts encrypted connections using TLS or SSL.</p> <h3 id="tls_event_clienterror">Event: 'clientError'</h3> <div class="api_metadata"> <span>Added in: v0.11.11</span> </div>
<p><code>function (exception, tlsSocket) { }</code></p> <p>When a client connection emits an <code>'error'</code> event before a secure connection is established it will be forwarded here.</p> <p><code>tlsSocket</code> is the <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> that the error originated from.</p> <h3 id="tls_event_newsession">Event: 'newSession'</h3> <div class="api_metadata"> <span>Added in: v0.9.2</span> </div>
<p><code>function (sessionId, sessionData, callback) { }</code></p> <p>Emitted on creation of TLS session. May be used to store sessions in external storage. <code>callback</code> must be invoked eventually, otherwise no data will be sent or received from secure connection.</p> <p>NOTE: adding this event listener will have an effect only on connections established after addition of event listener.</p> <h3 id="tls_event_ocsprequest">Event: 'OCSPRequest'</h3> <div class="api_metadata"> <span>Added in: v0.11.13</span> </div>
<p><code>function (certificate, issuer, callback) { }</code></p> <p>Emitted when the client sends a certificate status request. You could parse server's current certificate to obtain OCSP url and certificate id, and after obtaining OCSP response invoke <code>callback(null, resp)</code>, where <code>resp</code> is a <code>Buffer</code> instance. Both <code>certificate</code> and <code>issuer</code> are a <code>Buffer</code> DER-representations of the primary and issuer's certificates. They could be used to obtain OCSP certificate id and OCSP endpoint url.</p> <p>Alternatively, <code>callback(null, null)</code> could be called, meaning that there is no OCSP response.</p> <p>Calling <code>callback(err)</code> will result in a <code>socket.destroy(err)</code> call.</p> <p>Typical flow:</p> <ol> <li>Client connects to server and sends <code>'OCSPRequest'</code> to it (via status info extension in ClientHello.)</li> <li>Server receives request and invokes <code>'OCSPRequest'</code> event listener if present</li> <li>Server grabs OCSP url from either <code>certificate</code> or <code>issuer</code> and performs an <a href="https://en.wikipedia.org/wiki/OCSP_stapling" target="_blank">OCSP request</a> to the CA</li> <li>Server receives <code>OCSPResponse</code> from CA and sends it back to client via <code>callback</code> argument</li> <li>Client validates the response and either destroys socket or performs a handshake.</li> </ol> <p>NOTE: <code>issuer</code> could be null, if the certificate is self-signed or if the issuer is not in the root certificates list. (You could provide an issuer via <code>ca</code> option.)</p> <p>NOTE: adding this event listener will have an effect only on connections established after addition of event listener.</p> <p>NOTE: you may want to use some npm module like <a href="https://npmjs.org/package/asn1.js" target="_blank">asn1.js</a> to parse the certificates.</p> <h3 id="tls_event_resumesession">Event: 'resumeSession'</h3> <div class="api_metadata"> <span>Added in: v0.9.2</span> </div>
<p><code>function (sessionId, callback) { }</code></p> <p>Emitted when client wants to resume previous TLS session. Event listener may perform lookup in external storage using given <code>sessionId</code>, and invoke <code>callback(null, sessionData)</code> once finished. If session can't be resumed (i.e. doesn't exist in storage) one may call <code>callback(null, null)</code>. Calling <code>callback(err)</code> will terminate incoming connection and destroy socket.</p> <p>NOTE: adding this event listener will have an effect only on connections established after addition of event listener.</p> <p>Here's an example for using TLS session resumption:</p> <pre data-language="js">var tlsSessionStore = {};
server.on('newSession', (id, data, cb) =&gt; {
  tlsSessionStore[id.toString('hex')] = data;
  cb();
});
server.on('resumeSession', (id, cb) =&gt; {
  cb(null, tlsSessionStore[id.toString('hex')] || null);
});
</pre> <h3 id="tls_event_secureconnection">Event: 'secureConnection'</h3> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p><code>function (tlsSocket) {}</code></p> <p>This event is emitted after a new connection has been successfully handshaked. The argument is an instance of <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a>. It has all the common stream methods and events.</p> <p><code>socket.authorized</code> is a boolean value which indicates if the client has verified by one of the supplied certificate authorities for the server. If <code>socket.authorized</code> is false, then <code>socket.authorizationError</code> is set to describe how authorization failed. Implied but worth mentioning: depending on the settings of the TLS server, you unauthorized connections may be accepted.</p> <p><code>socket.npnProtocol</code> is a string containing the selected NPN protocol and <code>socket.alpnProtocol</code> is a string containing the selected ALPN protocol, When both NPN and ALPN extensions are received, ALPN takes precedence over NPN and the next protocol is selected by ALPN. When ALPN has no selected protocol, this returns false.</p> <p><code>socket.servername</code> is a string containing servername requested with SNI.</p> <h3 id="tls_server_addcontext_hostname_context">server.addContext(hostname, context)</h3> <div class="api_metadata"> <span>Added in: v0.5.3</span> </div>
<p>Add secure context that will be used if client request's SNI hostname is matching passed <code>hostname</code> (wildcards can be used). <code>context</code> can contain <code>key</code>, <code>cert</code>, <code>ca</code> and/or any other properties from <a href="#tls_tls_createsecurecontext_details"><code>tls.createSecureContext()</code></a> <code>options</code> argument.</p> <h3 id="tls_server_address">server.address()</h3> <div class="api_metadata"> <span>Added in: v0.6.0</span> </div>
<p>Returns the bound address, the address family name and port of the server as reported by the operating system. See <a href="../net/#net_server_address"><code>net.Server.address()</code></a> for more information.</p> <h3 id="tls_server_close_callback">server.close([callback])</h3> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p>Stops the server from accepting new connections. This function is asynchronous, the server is finally closed when the server emits a <code>'close'</code> event. Optionally, you can pass a callback to listen for the <code>'close'</code> event.</p> <h3 id="tls_server_connections">server.connections</h3> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p>The number of concurrent connections on the server.</p> <h3 id="tls_server_getticketkeys">server.getTicketKeys()</h3> <div class="api_metadata"> <span>Added in: v3.0.0</span> </div>
<p>Returns <code>Buffer</code> instance holding the keys currently used for encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt" target="_blank">TLS Session Tickets</a></p> <h3 id="tls_server_listen_port_hostname_callback">server.listen(port[, hostname][, callback])</h3> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the <code>hostname</code> is omitted, the server will accept connections on any IPv6 address (<code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. A port value of zero will assign a random port.</p> <p>This function is asynchronous. The last parameter <code>callback</code> will be called when the server has been bound.</p> <p>See <a href="../net/#net_class_net_server"><code>net.Server</code></a> for more information.</p> <h3 id="tls_server_maxconnections">server.maxConnections</h3> <div class="api_metadata"> <span>Added in: v0.2.0</span> </div>
<p>Set this property to reject connections when the server's connection count gets high.</p> <h3 id="tls_server_setticketkeys_keys">server.setTicketKeys(keys)</h3> <div class="api_metadata"> <span>Added in: v3.0.0</span> </div>
<p>Updates the keys for encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt" target="_blank">TLS Session Tickets</a>.</p> <p>NOTE: the buffer should be 48 bytes long. See server <code>ticketKeys</code> option for more information oh how it is going to be used.</p> <p>NOTE: the change is effective only for the future server connections. Existing or currently pending server connections will use previous keys.</p> <h2 id="tls_class_tls_tlssocket">Class: tls.TLSSocket</h2> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>This is a wrapped version of <a href="../net/#net_class_net_socket"><code>net.Socket</code></a> that does transparent encryption of written data and all required TLS negotiation.</p> <p>This instance implements a duplex <a href="../stream/#stream_stream">Stream</a> interfaces. It has all the common stream methods and events.</p> <p>Methods that return TLS connection meta data (e.g. <a href="#tls_tlssocket_getpeercertificate_detailed"><code>tls.TLSSocket.getPeerCertificate()</code></a> will only return data while the connection is open.</p> <h2 id="tls_new_tls_tlssocket_socket_options">new tls.TLSSocket(socket[, options])</h2> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Construct a new TLSSocket object from existing TCP socket.</p> <p><code>socket</code> is an instance of <a href="../net/#net_class_net_socket"><code>net.Socket</code></a></p> <p><code>options</code> is an optional object that might contain following properties:</p> <ul> <li>
<p><code>secureContext</code>: An optional TLS context object from <a href="#tls_tls_createsecurecontext_details"><code>tls.createSecureContext()</code></a></p> </li> <li>
<p><code>isServer</code>: If <code>true</code> the TLS socket will be instantiated in server-mode. Default: <code>false</code></p> </li> <li>
<p><code>server</code>: An optional <a href="../net/#net_class_net_server"><code>net.Server</code></a> instance</p> </li> <li>
<p><code>requestCert</code>: Optional, see <a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"><code>tls.createSecurePair()</code></a></p> </li> <li>
<p><code>rejectUnauthorized</code>: Optional, see <a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"><code>tls.createSecurePair()</code></a></p> </li> <li>
<p><code>NPNProtocols</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a></p> </li> <li>
<p><code>ALPNProtocols</code>: Optional, see [tls.createServer][]</p> </li> <li>
<p><code>SNICallback</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a></p> </li> <li>
<p><code>session</code>: Optional, a <code>Buffer</code> instance, containing TLS session</p> </li> <li>
<p><code>requestOCSP</code>: Optional, if <code>true</code> the OCSP status request extension will be added to the client hello, and an <code>'OCSPResponse'</code> event will be emitted on the socket before establishing a secure communication</p> </li> </ul> <h3 id="tls_event_ocspresponse">Event: 'OCSPResponse'</h3> <div class="api_metadata"> <span>Added in: v0.11.13</span> </div>
<p><code>function (response) { }</code></p> <p>This event will be emitted if <code>requestOCSP</code> option was set. <code>response</code> is a buffer object, containing server's OCSP response.</p> <p>Traditionally, the <code>response</code> is a signed object from the server's CA that contains information about server's certificate revocation status.</p> <h3 id="tls_event_secureconnect">Event: 'secureConnect'</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>This event is emitted after a new connection has been successfully handshaked. The listener will be called no matter if the server's certificate was authorized or not. It is up to the user to test <code>tlsSocket.authorized</code> to see if the server certificate was signed by one of the specified CAs. If <code>tlsSocket.authorized === false</code> then the error can be found in <code>tlsSocket.authorizationError</code>. Also if ALPN or NPN was used - you can check <code>tlsSocket.alpnProtocol</code> or <code>tlsSocket.npnProtocol</code> for the negotiated protocol.</p> <h3 id="tls_tlssocket_address">tlsSocket.address()</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Returns the bound address, the address family name and port of the underlying socket as reported by the operating system. Returns an object with three properties, e.g. <code>{ port: 12346, family: 'IPv4', address: '127.0.0.1' }</code></p> <h3 id="tls_tlssocket_authorized">tlsSocket.authorized</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the specified CAs, otherwise <code>false</code></p> <h3 id="tls_tlssocket_authorizationerror">tlsSocket.authorizationError</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The reason why the peer's certificate has not been verified. This property becomes available only when <code>tlsSocket.authorized === false</code>.</p> <h3 id="tls_tlssocket_encrypted">tlsSocket.encrypted</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Static boolean value, always <code>true</code>. May be used to distinguish TLS sockets from regular ones.</p> <h3 id="tls_tlssocket_getcipher">tlsSocket.getCipher()</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.</p> <p>Example: <span class="type">&lt;name: 'AES256-SHA', version: 'TLSv1/SSLv3'&gt;</span></p> <p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in <a href="https://www.openssl.org/docs/man1.0.2/ssl/ssl.html#DEALING-WITH-CIPHERS" target="_blank">https://www.openssl.org/docs/man1.0.2/ssl/ssl.html#DEALING-WITH-CIPHERS</a> for more information.</p> <h3 id="tls_tlssocket_getpeercertificate_detailed">tlsSocket.getPeerCertificate([ detailed ])</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Returns an object representing the peer's certificate. The returned object has some properties corresponding to the field of the certificate. If <code>detailed</code> argument is <code>true</code> the full chain with <code>issuer</code> property will be returned, if <code>false</code> only the top certificate without <code>issuer</code> property.</p> <p>Example:</p> <pre>{ subject:
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  issuerInfo:
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  issuer:
   { ... another certificate ... },
  raw: &lt; RAW DER buffer &gt;,
  valid_from: 'Nov 11 09:52:22 2009 GMT',
  valid_to: 'Nov  6 09:52:22 2029 GMT',
  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF',
  serialNumber: 'B9B0D332A1AA5635' }
</pre>
<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty object.</p> <h3 id="tls_tlssocket_getsession">tlsSocket.getSession()</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>Return ASN.1 encoded TLS session or <code>undefined</code> if none was negotiated. Could be used to speed up handshake establishment when reconnecting to the server.</p> <h3 id="tls_tlssocket_gettlsticket">tlsSocket.getTLSTicket()</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>NOTE: Works only with client TLS sockets. Useful only for debugging, for session reuse provide <code>session</code> option to <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a>.</p> <p>Return TLS session ticket or <code>undefined</code> if none was negotiated.</p> <h3 id="tls_tlssocket_localport">tlsSocket.localPort</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The numeric representation of the local port.</p> <h3 id="tls_tlssocket_localaddress">tlsSocket.localAddress</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The string representation of the local IP address.</p> <h3 id="tls_tlssocket_remoteaddress">tlsSocket.remoteAddress</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The string representation of the remote IP address. For example, <code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p> <h3 id="tls_tlssocket_remotefamily">tlsSocket.remoteFamily</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The string representation of the remote IP family. <code>'IPv4'</code> or <code>'IPv6'</code>.</p> <h3 id="tls_tlssocket_remoteport">tlsSocket.remotePort</h3> <div class="api_metadata"> <span>Added in: v0.11.4</span> </div>
<p>The numeric representation of the remote port. For example, <code>443</code>.</p> <h3 id="tls_tlssocket_renegotiate_options_callback">tlsSocket.renegotiate(options, callback)</h3> <div class="api_metadata"> <span>Added in: v0.11.8</span> </div>
<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following fields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> for details). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>, once the renegotiation is successfully completed.</p> <p>NOTE: Can be used to request peer's certificate after the secure connection has been established.</p> <p>ANOTHER NOTE: When running as the server, socket will be destroyed with an error after <code>handshakeTimeout</code> timeout.</p> <h3 id="tls_tlssocket_setmaxsendfragment_size">tlsSocket.setMaxSendFragment(size)</h3> <div class="api_metadata"> <span>Added in: v0.11.11</span> </div>
<p>Set maximum TLS fragment size (default and maximum value is: <code>16384</code>, minimum is: <code>512</code>). Returns <code>true</code> on success, <code>false</code> otherwise.</p> <p>Smaller fragment size decreases buffering latency on the client: large fragments are buffered by the TLS layer until the entire fragment is received and its integrity is verified; large fragments can span multiple roundtrips, and their processing can be delayed due to packet loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead, which may decrease overall server throughput.</p> <h2 id="tls_tls_connect_options_callback">tls.connect(options[, callback])</h2> <h2 id="tls_tls_connect_port_host_options_callback">tls.connect(port[, host][, options][, callback])</h2> <div class="api_metadata"> <span>Added in: v0.11.3</span> </div>
<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or <code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to <code>localhost</code>.) <code>options</code> should be an object which specifies:</p> <ul> <li>
<p><code>host</code>: Host the client should connect to</p> </li> <li>
<p><code>port</code>: Port the client should connect to</p> </li> <li>
<p><code>socket</code>: Establish secure connection on a given socket rather than creating a new socket. If this option is specified, <code>host</code> and <code>port</code> are ignored.</p> </li> <li>
<p><code>path</code>: Creates unix socket connection to path. If this option is specified, <code>host</code> and <code>port</code> are ignored.</p> </li> <li>
<p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and CA certs of the client in PFX or PKCS12 format.</p> </li> <li>
<p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in PEM format. (Could be an array of keys).</p> </li> <li>
<p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p> </li> <li>
<p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in PEM format. (Could be an array of certs).</p> </li> <li>
<p><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted certificates in PEM format. If this is omitted several well known "root" CAs will be used, like VeriSign. These are used to authorize connections.</p> </li> <li>
<p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by <code>:</code>. Uses the same default cipher suite as <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a>.</p> </li> <li>
<p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against the list of supplied CAs. An <code>'error'</code> event is emitted if verification fails; <code>err.code</code> contains the OpenSSL error code. Default: <code>true</code>.</p> </li> <li>
<p><code>NPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported NPN protocols. <code>Buffer</code>s should have following format: <code>0x05hello0x05world</code>, where first byte is next protocol name's length. (Passing array should usually be much simpler: <code>['hello', 'world']</code>.)</p> </li> <li>
<p><code>ALPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported ALPN protocols. <code>Buffer</code>s should have following format: <code>0x05hello0x05world</code>, where the first byte is the next protocol name's length. (Passing array should usually be much simpler: <code>['hello', 'world']</code>.)</p> </li> <li>
<p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p> </li> <li>
<p><code>checkServerIdentity(servername, cert)</code>: Provide an override for checking server's hostname against the certificate. Should return an error if verification fails. Return <code>undefined</code> if passing.</p> </li> <li>
<p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force SSL version 3. The possible values depend on your installation of OpenSSL and are defined in the constant <a href="https://www.openssl.org/docs/man1.0.2/ssl/ssl.html#DEALING-WITH-PROTOCOL-METHODS" target="_blank">SSL_METHODS</a>.</p> </li> <li>
<p><code>secureContext</code>: An optional TLS context object from <code>tls.createSecureContext( ... )</code>. Could it be used for caching client certificates, key, and CA certificates.</p> </li> <li>
<p><code>session</code>: A <code>Buffer</code> instance, containing TLS session.</p> </li> </ul> <p>The <code>callback</code> parameter will be added as a listener for the <a href="#tls_event_secureconnect"><code>'secureConnect'</code></a> event.</p> <p><code>tls.connect()</code> returns a <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> object.</p> <p>Here is an example of a client of echo server as described previously:</p> <pre data-language="js">const tls = require('tls');
const fs = require('fs');

const options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync('server-cert.pem') ]
};

var socket = tls.connect(8000, options, () =&gt; {
  console.log('client connected',
              socket.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding('utf8');
socket.on('data', (data) =&gt; {
  console.log(data);
});
socket.on('end', () =&gt; {
  server.close();
});
</pre> <p>Or</p> <pre data-language="js">const tls = require('tls');
const fs = require('fs');

const options = {
  pfx: fs.readFileSync('client.pfx')
};

var socket = tls.connect(8000, options, () =&gt; {
  console.log('client connected',
              socket.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding('utf8');
socket.on('data', (data) =&gt; {
  console.log(data);
});
socket.on('end', () =&gt; {
  server.close();
});
</pre> <h2 id="tls_tls_createsecurecontext_details">tls.createSecureContext(details)</h2> <div class="api_metadata"> <span>Added in: v0.11.13</span> </div>
<p>Creates a credentials object, with the optional details being a dictionary with keys:</p> <ul> <li>
<code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private key, certificate and CA certificates</li> <li>
<code>key</code>: A string or <code>Buffer</code> containing the private key of the server in PEM format. To support multiple keys using different algorithms, an array can be provided. It can either be a plain array of keys, or an array of objects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</li> <li>
<code>passphrase</code> : A string of passphrase for the private key or pfx</li> <li>
<code>cert</code> : A string holding the PEM encoded certificate</li> <li>
<code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted certificates in PEM format. If this is omitted several well known "root" CAs will be used, like VeriSign. These are used to authorize connections.</li> <li>
<code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)</li> <li>
<code>ciphers</code>: A string describing the ciphers to use or exclude. Consult <a href="https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT" target="_blank">https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT</a> for details on the format.</li> <li>
<code>honorCipherOrder</code> : When choosing a cipher, use the server's preferences instead of the client preferences. For further details see <code>tls</code> module documentation.</li> </ul> <p>If no 'ca' details are given, then Node.js will use the default publicly trusted list of CAs as given in <a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt" target="_blank">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p> <h2 id="tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options">tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</h2> <p>Creates a new secure pair object with two streams, one of which reads/writes encrypted data, and one reads/writes cleartext data. Generally the encrypted one is piped to/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream.</p> <ul> <li>
<p><code>credentials</code>: A secure context object from tls.createSecureContext( ... )</p> </li> <li>
<p><code>isServer</code>: A boolean indicating whether this tls connection should be opened as a server or a client.</p> </li> <li>
<p><code>requestCert</code>: A boolean indicating whether a server should request a certificate from a connecting client. Only applies to server connections.</p> </li> <li>
<p><code>rejectUnauthorized</code>: A boolean indicating whether a server should automatically reject clients with invalid certificates. Only applies to servers with <code>requestCert</code> enabled.</p> </li> <li>
<p><code>options</code>: An object with common SSL options. See <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a>.</p> </li> </ul> <p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and <code>encrypted</code> stream properties.</p> <p>NOTE: <code>cleartext</code> has the same APIs as <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a></p> <h2 id="tls_tls_createserver_options_secureconnectionlistener">tls.createServer(options[, secureConnectionListener])</h2> <div class="api_metadata"> <span>Added in: v0.3.2</span> </div>
<p>Creates a new <a href="#tls_class_tls_server">tls.Server</a>. The <code>connectionListener</code> argument is automatically set as a listener for the <a href="#tls_event_secureconnection"><code>'secureConnection'</code></a> event. The <code>options</code> object has these possibilities:</p> <ul> <li>
<p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p> </li> <li>
<p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in PEM format. To support multiple keys using different algorithms, an array can be provided. It can either be a plain array of keys, or an array of objects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</p> </li> <li>
<p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p> </li> <li>
<p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in PEM format. (Could be an array of certs). (Required)</p> </li> <li>
<p><code>ca</code>: A string, <code>Buffer</code> or array of strings or <code>Buffer</code>s of trusted certificates in PEM format. If this is omitted several well known "root" CAs will be used, like VeriSign. These are used to authorize connections.</p> </li> <li>
<p><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate Revocation List)</p> </li> <li>
<p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by <code>:</code>. The default cipher suite is:</p> <pre data-language="js">ECDHE-RSA-AES128-GCM-SHA256:
ECDHE-ECDSA-AES128-GCM-SHA256:
ECDHE-RSA-AES256-GCM-SHA384:
ECDHE-ECDSA-AES256-GCM-SHA384:
DHE-RSA-AES128-GCM-SHA256:
ECDHE-RSA-AES128-SHA256:
DHE-RSA-AES128-SHA256:
ECDHE-RSA-AES256-SHA384:
DHE-RSA-AES256-SHA384:
ECDHE-RSA-AES256-SHA256:
DHE-RSA-AES256-SHA256:
HIGH:
!aNULL:
!eNULL:
!EXPORT:
!DES:
!RC4:
!MD5:
!PSK:
!SRP:
!CAMELLIA
</pre> <p>The default cipher suite prefers GCM ciphers for <a href="https://www.chromium.org/Home/chromium-security/education/tls#TOC-Deprecation-of-TLS-Features-Algorithms-in-Chrome" target="_blank">Chrome's 'modern cryptography' setting</a> and also prefers ECDHE and DHE ciphers for Perfect Forward secrecy, while offering <em>some</em> backward compatibiltity.</p> <p>128 bit AES is preferred over 192 and 256 bit AES in light of <a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html" target="_blank">specific attacks affecting larger AES key sizes</a>.</p> <p>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers (like Internet Explorer 6) aren't able to complete the handshake with the default configuration. If you absolutely must support these clients, the <a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank">TLS recommendations</a> may offer a compatible cipher suite. For more details on the format, see the <a href="https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT" target="_blank">OpenSSL cipher list format documentation</a>.</p> </li> <li>
<p><code>ecdhCurve</code>: A string describing a named curve to use for ECDH key agreement or false to disable ECDH.</p> <p>Defaults to <code>prime256v1</code> (NIST P-256). Use <a href="../crypto/#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a> to obtain a list of available curve names. On recent releases, <code>openssl ecparam -list_curves</code> will also display the name and description of each available elliptic curve.</p> </li> <li>
<p><code>dhparam</code>: A string or <code>Buffer</code> containing Diffie Hellman parameters, required for Perfect Forward Secrecy. Use <code>openssl dhparam</code> to create it. Its key length should be greater than or equal to 1024 bits, otherwise it throws an error. It is strongly recommended to use 2048 bits or more for stronger security. If omitted or invalid, it is silently discarded and DHE ciphers won't be available.</p> </li> <li>
<p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not finish in this many milliseconds. The default is 120 seconds.</p> <p>A <code>'clientError'</code> is emitted on the <code>tls.Server</code> object whenever a handshake times out.</p> </li> <li>
<p><code>honorCipherOrder</code> : When choosing a cipher, use the server's preferences instead of the client preferences. Default: <code>true</code>.</p> </li> <li>
<p><code>requestCert</code>: If <code>true</code> the server will request a certificate from clients that connect and attempt to verify that certificate. Default: <code>false</code>.</p> </li> <li>
<p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p> </li> <li>
<p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols should be ordered by their priority).</p> </li> <li>
<p><code>ALPNProtocols</code>: An array or <code>Buffer</code> of possible ALPN protocols. (Protocols should be ordered by their priority). When the server receives both NPN and ALPN extensions from the client, ALPN takes precedence over NPN and the server does not send an NPN extension to the client.</p> </li> <li>
<p><code>SNICallback(servername, cb)</code>: A function that will be called if client supports SNI TLS extension. Two argument will be passed to it: <code>servername</code>, and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a SecureContext instance. (You can use <code>tls.createSecureContext(...)</code> to get proper SecureContext). If <code>SNICallback</code> wasn't provided the default callback with high-level API will be used (see below).</p> </li> <li>
<p><code>sessionTimeout</code>: An integer specifying the seconds after which TLS session identifiers and TLS session tickets created by the server are timed out. See <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_timeout.html" target="_blank">SSL_CTX_set_timeout</a> for more details.</p> </li> <li>
<p><code>ticketKeys</code>: A 48-byte <code>Buffer</code> instance consisting of 16-byte prefix, 16-byte hmac key, 16-byte AES key. You could use it to accept tls session tickets on multiple instances of tls server.</p> <p>NOTE: Automatically shared between <code>cluster</code> module workers.</p> </li> <li>
<p><code>sessionIdContext</code>: A string containing an opaque identifier for session resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value generated from command-line. (In FIPS mode a truncated SHA1 hash is used instead.) Otherwise, the default is not provided.</p> </li> <li>
<p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force SSL version 3. The possible values depend on your installation of OpenSSL and are defined in the constant <a href="https://www.openssl.org/docs/man1.0.2/ssl/ssl.html#DEALING-WITH-PROTOCOL-METHODS" target="_blank">SSL_METHODS</a>.</p> </li> </ul> <p>Here is a simple example echo server:</p> <pre data-language="js">const tls = require('tls');
const fs = require('fs');

const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync('client-cert.pem') ]
};

var server = tls.createServer(options, (socket) =&gt; {
  console.log('server connected',
              socket.authorized ? 'authorized' : 'unauthorized');
  socket.write('welcome!\n');
  socket.setEncoding('utf8');
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log('server bound');
});
</pre> <p>Or</p> <pre data-language="js">const tls = require('tls');
const fs = require('fs');

const options = {
  pfx: fs.readFileSync('server.pfx'),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

};

var server = tls.createServer(options, (socket) =&gt; {
  console.log('server connected',
              socket.authorized ? 'authorized' : 'unauthorized');
  socket.write('welcome!\n');
  socket.setEncoding('utf8');
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log('server bound');
});
</pre> <p>You can test this server by connecting to it with <code>openssl s_client</code>:</p> <pre>openssl s_client -connect 127.0.0.1:8000
</pre>
<h2 id="tls_tls_getciphers">tls.getCiphers()</h2> <div class="api_metadata"> <span>Added in: v0.10.2</span> </div>
<p>Returns an array with the names of the supported SSL ciphers.</p> <p>Example:</p> <pre data-language="js">var ciphers = tls.getCiphers();
console.log(ciphers); // ['AES128-SHA', 'AES256-SHA', ...]
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    Â© Joyent, Inc. and other Node contributors<br>Licensed under the MIT License.<br>Node.js is a trademark of Joyent, Inc. and is used with its permission.<br>We are not endorsed by or affiliated with Joyent.<br>
    <a href="https://nodejs.org/dist/latest-v4.x/docs/api/tls.html" class="_attribution-link" target="_blank">https://nodejs.org/dist/latest-v4.x/docs/api/tls.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
