
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Crypto&#47;tls - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446. ">
  <meta name="keywords" content="package, tls, crypto, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/crypto/tls/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _go">
				
				
<h1> Package tls  </h1>    <ul id="short-nav">
<li><code>import "crypto/tls"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p> Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446. </p> <p> TLS 1.3 is available on an opt-out basis in Go 1.13. To disable it, set the GODEBUG environment variable (comma-separated key=value options) such that it includes "tls13=0". </p>      <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#Listen">func Listen(network, laddr string, config *Config) (net.Listener, error)</a></li>
<li><a href="#NewListener">func NewListener(inner net.Listener, config *Config) net.Listener</a></li>
<li><a href="#Certificate">type Certificate</a></li>
<li> <a href="#LoadX509KeyPair">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</a>
</li>
<li> <a href="#X509KeyPair">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</a>
</li>
<li><a href="#CertificateRequestInfo">type CertificateRequestInfo</a></li>
<li><a href="#ClientAuthType">type ClientAuthType</a></li>
<li><a href="#ClientHelloInfo">type ClientHelloInfo</a></li>
<li><a href="#ClientSessionCache">type ClientSessionCache</a></li>
<li> <a href="#NewLRUClientSessionCache">func NewLRUClientSessionCache(capacity int) ClientSessionCache</a>
</li>
<li><a href="#ClientSessionState">type ClientSessionState</a></li>
<li><a href="#Config">type Config</a></li>
<li> <a href="#Config.BuildNameToCertificate">func (c *Config) BuildNameToCertificate()</a>
</li>
<li> <a href="#Config.Clone">func (c *Config) Clone() *Config</a>
</li>
<li> <a href="#Config.SetSessionTicketKeys">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</a>
</li>
<li><a href="#Conn">type Conn</a></li>
<li> <a href="#Client">func Client(conn net.Conn, config *Config) *Conn</a>
</li>
<li> <a href="#Dial">func Dial(network, addr string, config *Config) (*Conn, error)</a>
</li>
<li> <a href="#DialWithDialer">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</a>
</li>
<li> <a href="#Server">func Server(conn net.Conn, config *Config) *Conn</a>
</li>
<li> <a href="#Conn.Close">func (c *Conn) Close() error</a>
</li>
<li> <a href="#Conn.CloseWrite">func (c *Conn) CloseWrite() error</a>
</li>
<li> <a href="#Conn.ConnectionState">func (c *Conn) ConnectionState() ConnectionState</a>
</li>
<li> <a href="#Conn.Handshake">func (c *Conn) Handshake() error</a>
</li>
<li> <a href="#Conn.LocalAddr">func (c *Conn) LocalAddr() net.Addr</a>
</li>
<li> <a href="#Conn.OCSPResponse">func (c *Conn) OCSPResponse() []byte</a>
</li>
<li> <a href="#Conn.Read">func (c *Conn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#Conn.RemoteAddr">func (c *Conn) RemoteAddr() net.Addr</a>
</li>
<li> <a href="#Conn.SetDeadline">func (c *Conn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.SetReadDeadline">func (c *Conn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.SetWriteDeadline">func (c *Conn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.VerifyHostname">func (c *Conn) VerifyHostname(host string) error</a>
</li>
<li> <a href="#Conn.Write">func (c *Conn) Write(b []byte) (int, error)</a>
</li>
<li><a href="#ConnectionState">type ConnectionState</a></li>
<li> <a href="#ConnectionState.ExportKeyingMaterial">func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)</a>
</li>
<li><a href="#CurveID">type CurveID</a></li>
<li><a href="#RecordHeaderError">type RecordHeaderError</a></li>
<li> <a href="#RecordHeaderError.Error">func (e RecordHeaderError) Error() string</a>
</li>
<li><a href="#RenegotiationSupport">type RenegotiationSupport</a></li>
<li><a href="#SignatureScheme">type SignatureScheme</a></li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Config_keyLogWriter">Config (KeyLogWriter)</a></dd> <dd><a class="exampleLink" href="#example_Dial">Dial</a></dd> <dd><a class="exampleLink" href="#example_LoadX509KeyPair">LoadX509KeyPair</a></dd> <dd><a class="exampleLink" href="#example_X509KeyPair">X509KeyPair</a></dd> <dd><a class="exampleLink" href="#example_X509KeyPair_httpServer">X509KeyPair (HttpServer)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/crypto/tls/alert.go" target="_blank">alert.go</a> <a href="https://golang.org/src/crypto/tls/auth.go" target="_blank">auth.go</a> <a href="https://golang.org/src/crypto/tls/cipher_suites.go" target="_blank">cipher_suites.go</a> <a href="https://golang.org/src/crypto/tls/common.go" target="_blank">common.go</a> <a href="https://golang.org/src/crypto/tls/conn.go" target="_blank">conn.go</a> <a href="https://golang.org/src/crypto/tls/handshake_client.go" target="_blank">handshake_client.go</a> <a href="https://golang.org/src/crypto/tls/handshake_client_tls13.go" target="_blank">handshake_client_tls13.go</a> <a href="https://golang.org/src/crypto/tls/handshake_messages.go" target="_blank">handshake_messages.go</a> <a href="https://golang.org/src/crypto/tls/handshake_server.go" target="_blank">handshake_server.go</a> <a href="https://golang.org/src/crypto/tls/handshake_server_tls13.go" target="_blank">handshake_server_tls13.go</a> <a href="https://golang.org/src/crypto/tls/key_agreement.go" target="_blank">key_agreement.go</a> <a href="https://golang.org/src/crypto/tls/key_schedule.go" target="_blank">key_schedule.go</a> <a href="https://golang.org/src/crypto/tls/prf.go" target="_blank">prf.go</a> <a href="https://golang.org/src/crypto/tls/ticket.go" target="_blank">ticket.go</a> <a href="https://golang.org/src/crypto/tls/tls.go" target="_blank">tls.go</a>  </p>   <h2 id="pkg-constants">Constants</h2> <p> A list of cipher suite IDs that are, or have been, implemented by this package. </p> <p> Taken from <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml" target="_blank">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml</a> </p> <pre data-language="go">const (
    // TLS 1.0 - 1.2 cipher suites.
    TLS_RSA_WITH_RC4_128_SHA                uint16 = 0x0005
    TLS_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0x000a
    TLS_RSA_WITH_AES_128_CBC_SHA            uint16 = 0x002f
    TLS_RSA_WITH_AES_256_CBC_SHA            uint16 = 0x0035
    TLS_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0x003c
    TLS_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0x009c
    TLS_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0x009d
    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        uint16 = 0xc007
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    uint16 = 0xc009
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    uint16 = 0xc00a
    TLS_ECDHE_RSA_WITH_RC4_128_SHA          uint16 = 0xc011
    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0xc012
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0xc013
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0xc014
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc023
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   uint16 = 0xc027
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   uint16 = 0xc02f
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   uint16 = 0xc030
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305    uint16 = 0xcca8
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305  uint16 = 0xcca9

    // TLS 1.3 cipher suites.
    TLS_AES_128_GCM_SHA256       uint16 = 0x1301
    TLS_AES_256_GCM_SHA384       uint16 = 0x1302
    TLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303

    // TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator
    // that the client is doing version fallback. See RFC 7507.
    TLS_FALLBACK_SCSV uint16 = 0x5600
)</pre> <pre data-language="go">const (
    VersionTLS10 = 0x0301
    VersionTLS11 = 0x0302
    VersionTLS12 = 0x0303
    VersionTLS13 = 0x0304

    // Deprecated: SSLv3 is cryptographically broken, and will be
    // removed in Go 1.14. See golang.org/issue/32716.
    VersionSSL30 = 0x0300
)</pre> <h2 id="Listen">func Listen<a href="https://golang.org/src/crypto/tls/tls.go?s=2529:2601#L71" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func Listen(network, laddr string, config *Config) (net.Listener, error)</pre> <p> Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h2 id="NewListener">func NewListener<a href="https://golang.org/src/crypto/tls/tls.go?s=2167:2232#L60" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func NewListener(inner net.Listener, config *Config) net.Listener</pre> <p> NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h2 id="Certificate">type Certificate<a href="https://golang.org/src/crypto/tls/common.go?s=36047:36965#L988" class="source" target="_blank">Source</a>  </h2> <p> A Certificate is a chain of one or more certificates, leaf first. </p> <pre data-language="go">type Certificate struct {
    Certificate [][]byte
    // PrivateKey contains the private key corresponding to the public key in
    // Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.
    // For a server up to TLS 1.2, it can also implement crypto.Decrypter with
    // an RSA PublicKey.
    PrivateKey crypto.PrivateKey
    // OCSPStaple contains an optional OCSP response which will be served
    // to clients that request it.
    OCSPStaple []byte
    // SignedCertificateTimestamps contains an optional list of Signed
    // Certificate Timestamps which will be served to clients that request it.
    SignedCertificateTimestamps [][]byte // Go 1.5
    // Leaf is the parsed form of the leaf certificate, which may be
    // initialized using x509.ParseCertificate to reduce per-handshake
    // processing for TLS clients doing client authentication. If nil, the
    // leaf certificate will be parsed as needed.
    Leaf *x509.Certificate
}
</pre> <h3 id="LoadX509KeyPair">func LoadX509KeyPair<a href="https://golang.org/src/crypto/tls/tls.go?s=5662:5729#L175" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</pre> <p> LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p>    <h4 id="example_LoadX509KeyPair"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/tls"
	"log"
)

func main() {
	cert, err := tls.LoadX509KeyPair("testdata/example-cert.pem", "testdata/example-key.pem")
	if err != nil {
		log.Fatal(err)
	}
	cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
	listener, err := tls.Listen("tcp", ":2000", cfg)
	if err != nil {
		log.Fatal(err)
	}
	_ = listener
}
</pre>   <h3 id="X509KeyPair">func X509KeyPair<a href="https://golang.org/src/crypto/tls/tls.go?s=6170:6241#L190" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</pre> <p> X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p>    <h4 id="example_X509KeyPair"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/tls"
	"log"
)

func main() {
	certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
	keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
	cert, err := tls.X509KeyPair(certPem, keyPem)
	if err != nil {
		log.Fatal(err)
	}
	cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
	listener, err := tls.Listen("tcp", ":2000", cfg)
	if err != nil {
		log.Fatal(err)
	}
	_ = listener
}
</pre>      <h4 id="example_X509KeyPair_httpServer"> <span class="text">Example (HttpServer)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/tls"
	"log"
	"net/http"
	"time"
)

func main() {
	certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
	keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
	cert, err := tls.X509KeyPair(certPem, keyPem)
	if err != nil {
		log.Fatal(err)
	}
	cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
	srv := &amp;http.Server{
		TLSConfig:    cfg,
		ReadTimeout:  time.Minute,
		WriteTimeout: time.Minute,
	}
	log.Fatal(srv.ListenAndServeTLS("", ""))
}
</pre>   <h2 id="CertificateRequestInfo">type CertificateRequestInfo<a href="https://golang.org/src/crypto/tls/common.go?s=14463:14919#L383" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client. </p> <pre data-language="go">type CertificateRequestInfo struct {
    // AcceptableCAs contains zero or more, DER-encoded, X.501
    // Distinguished Names. These are the names of root or intermediate CAs
    // that the server wishes the returned certificate to be signed by. An
    // empty slice indicates that the server has no preference.
    AcceptableCAs [][]byte

    // SignatureSchemes lists the signature schemes that the server is
    // willing to verify.
    SignatureSchemes []SignatureScheme
}
</pre> <h2 id="ClientAuthType">type ClientAuthType<a href="https://golang.org/src/crypto/tls/common.go?s=8937:8960#L249" class="source" target="_blank">Source</a>  </h2> <p> ClientAuthType declares the policy the server will follow for TLS Client Authentication. </p> <pre data-language="go">type ClientAuthType int</pre> <pre data-language="go">const (
    NoClientCert ClientAuthType = iota
    RequestClientCert
    RequireAnyClientCert
    VerifyClientCertIfGiven
    RequireAndVerifyClientCert
)</pre> <h2 id="ClientHelloInfo">type ClientHelloInfo<a href="https://golang.org/src/crypto/tls/common.go?s=12391:14290#L335" class="source" target="_blank">Source</a>  <span title="Added in Go 1.4">1.4</span> </h2> <p> ClientHelloInfo contains information from a ClientHello message in order to guide certificate selection in the GetCertificate callback. </p> <pre data-language="go">type ClientHelloInfo struct {
    // CipherSuites lists the CipherSuites supported by the client (e.g.
    // TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).
    CipherSuites []uint16

    // ServerName indicates the name of the server requested by the client
    // in order to support virtual hosting. ServerName is only set if the
    // client is using SNI (see RFC 4366, Section 3.1).
    ServerName string

    // SupportedCurves lists the elliptic curves supported by the client.
    // SupportedCurves is set only if the Supported Elliptic Curves
    // Extension is being used (see RFC 4492, Section 5.1.1).
    SupportedCurves []CurveID

    // SupportedPoints lists the point formats supported by the client.
    // SupportedPoints is set only if the Supported Point Formats Extension
    // is being used (see RFC 4492, Section 5.1.2).
    SupportedPoints []uint8

    // SignatureSchemes lists the signature and hash schemes that the client
    // is willing to verify. SignatureSchemes is set only if the Signature
    // Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).
    SignatureSchemes []SignatureScheme // Go 1.8

    // SupportedProtos lists the application protocols supported by the client.
    // SupportedProtos is set only if the Application-Layer Protocol
    // Negotiation Extension is being used (see RFC 7301, Section 3.1).
    //
    // Servers can select a protocol by setting Config.NextProtos in a
    // GetConfigForClient return value.
    SupportedProtos []string // Go 1.8

    // SupportedVersions lists the TLS versions supported by the client.
    // For TLS versions less than 1.3, this is extrapolated from the max
    // version advertised by the client, so values other than the greatest
    // might be rejected if used.
    SupportedVersions []uint16 // Go 1.8

    // Conn is the underlying net.Conn for the connection. Do not read
    // from, or write to, this connection; that will cause the TLS
    // connection to fail.
    Conn net.Conn // Go 1.8
}
</pre> <h2 id="ClientSessionCache">type ClientSessionCache<a href="https://golang.org/src/crypto/tls/common.go?s=10819:11352#L293" class="source" target="_blank">Source</a>  <span title="Added in Go 1.3">1.3</span> </h2> <p> ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface. </p> <pre data-language="go">type ClientSessionCache interface {
    // Get searches for a ClientSessionState associated with the given key.
    // On return, ok is true if one was found.
    Get(sessionKey string) (session *ClientSessionState, ok bool)

    // Put adds the ClientSessionState to the cache with the given key. It might
    // get called multiple times in a connection if a TLS 1.3 server provides
    // more than one session ticket. If called with a nil *ClientSessionState,
    // it should remove the cache entry.
    Put(sessionKey string, cs *ClientSessionState)
}</pre> <h3 id="NewLRUClientSessionCache">func NewLRUClientSessionCache<a href="https://golang.org/src/crypto/tls/common.go?s=37517:37579#L1031" class="source" target="_blank">Source</a>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func NewLRUClientSessionCache(capacity int) ClientSessionCache</pre> <p> NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity is used instead. </p> <h2 id="ClientSessionState">type ClientSessionState<a href="https://golang.org/src/crypto/tls/common.go?s=9457:10389#L272" class="source" target="_blank">Source</a>  <span title="Added in Go 1.3">1.3</span> </h2> <p> ClientSessionState contains the state needed by clients to resume TLS sessions. </p> <pre data-language="go">type ClientSessionState struct {
    // contains filtered or unexported fields
}
</pre> <h2 id="Config">type Config<a href="https://golang.org/src/crypto/tls/common.go?s=16307:25155#L428" class="source" target="_blank">Source</a>  </h2> <p> A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it. </p> <pre data-language="go">type Config struct {
    // Rand provides the source of entropy for nonces and RSA blinding.
    // If Rand is nil, TLS uses the cryptographic random reader in package
    // crypto/rand.
    // The Reader must be safe for use by multiple goroutines.
    Rand io.Reader

    // Time returns the current time as the number of seconds since the epoch.
    // If Time is nil, TLS uses time.Now.
    Time func() time.Time

    // Certificates contains one or more certificate chains to present to
    // the other side of the connection. Server configurations must include
    // at least one certificate or else set GetCertificate. Clients doing
    // client-authentication may set either Certificates or
    // GetClientCertificate.
    Certificates []Certificate

    // NameToCertificate maps from a certificate name to an element of
    // Certificates. Note that a certificate name can be of the form
    // '*.example.com' and so doesn't have to be a domain name as such.
    // See Config.BuildNameToCertificate
    // The nil value causes the first element of Certificates to be used
    // for all connections.
    NameToCertificate map[string]*Certificate

    // GetCertificate returns a Certificate based on the given
    // ClientHelloInfo. It will only be called if the client supplies SNI
    // information or if Certificates is empty.
    //
    // If GetCertificate is nil or returns nil, then the certificate is
    // retrieved from NameToCertificate. If NameToCertificate is nil, the
    // first element of Certificates will be used.
    GetCertificate func(*ClientHelloInfo) (*Certificate, error) // Go 1.4

    // GetClientCertificate, if not nil, is called when a server requests a
    // certificate from a client. If set, the contents of Certificates will
    // be ignored.
    //
    // If GetClientCertificate returns an error, the handshake will be
    // aborted and that error will be returned. Otherwise
    // GetClientCertificate must return a non-nil Certificate. If
    // Certificate.Certificate is empty then no certificate will be sent to
    // the server. If this is unacceptable to the server then it may abort
    // the handshake.
    //
    // GetClientCertificate may be called multiple times for the same
    // connection if renegotiation occurs or if TLS 1.3 is in use.
    GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error) // Go 1.8

    // GetConfigForClient, if not nil, is called after a ClientHello is
    // received from a client. It may return a non-nil Config in order to
    // change the Config that will be used to handle this connection. If
    // the returned Config is nil, the original Config will be used. The
    // Config returned by this callback may not be subsequently modified.
    //
    // If GetConfigForClient is nil, the Config passed to Server() will be
    // used for all connections.
    //
    // Uniquely for the fields in the returned Config, session ticket keys
    // will be duplicated from the original Config if not set.
    // Specifically, if SetSessionTicketKeys was called on the original
    // config but not on the returned config then the ticket keys from the
    // original config will be copied into the new config before use.
    // Otherwise, if SessionTicketKey was set in the original config but
    // not in the returned config then it will be copied into the returned
    // config before use. If neither of those cases applies then the key
    // material from the returned config will be used for session tickets.
    GetConfigForClient func(*ClientHelloInfo) (*Config, error) // Go 1.8

    // VerifyPeerCertificate, if not nil, is called after normal
    // certificate verification by either a TLS client or server. It
    // receives the raw ASN.1 certificates provided by the peer and also
    // any verified chains that normal processing found. If it returns a
    // non-nil error, the handshake is aborted and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. If normal verification is disabled by
    // setting InsecureSkipVerify, or (for a server) when ClientAuth is
    // RequestClientCert or RequireAnyClientCert, then this callback will
    // be considered but the verifiedChains argument will always be nil.
    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8

    // RootCAs defines the set of root certificate authorities
    // that clients use when verifying server certificates.
    // If RootCAs is nil, TLS uses the host's root CA set.
    RootCAs *x509.CertPool

    // NextProtos is a list of supported application level protocols, in
    // order of preference.
    NextProtos []string

    // ServerName is used to verify the hostname on the returned
    // certificates unless InsecureSkipVerify is given. It is also included
    // in the client's handshake to support virtual hosting unless it is
    // an IP address.
    ServerName string

    // ClientAuth determines the server's policy for
    // TLS Client Authentication. The default is NoClientCert.
    ClientAuth ClientAuthType

    // ClientCAs defines the set of root certificate authorities
    // that servers use if required to verify a client certificate
    // by the policy in ClientAuth.
    ClientCAs *x509.CertPool

    // InsecureSkipVerify controls whether a client verifies the
    // server's certificate chain and host name.
    // If InsecureSkipVerify is true, TLS accepts any certificate
    // presented by the server and any host name in that certificate.
    // In this mode, TLS is susceptible to man-in-the-middle attacks.
    // This should be used only for testing.
    InsecureSkipVerify bool

    // CipherSuites is a list of supported cipher suites for TLS versions up to
    // TLS 1.2. If CipherSuites is nil, a default list of secure cipher suites
    // is used, with a preference order based on hardware performance. The
    // default cipher suites might change over Go versions. Note that TLS 1.3
    // ciphersuites are not configurable.
    CipherSuites []uint16

    // PreferServerCipherSuites controls whether the server selects the
    // client's most preferred ciphersuite, or the server's most preferred
    // ciphersuite. If true then the server's preference, as expressed in
    // the order of elements in CipherSuites, is used.
    PreferServerCipherSuites bool // Go 1.1

    // SessionTicketsDisabled may be set to true to disable session ticket and
    // PSK (resumption) support. Note that on clients, session ticket support is
    // also disabled if ClientSessionCache is nil.
    SessionTicketsDisabled bool // Go 1.1

    // SessionTicketKey is used by TLS servers to provide session resumption.
    // See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled
    // with random data before the first server handshake.
    //
    // If multiple servers are terminating connections for the same host
    // they should all have the same SessionTicketKey. If the
    // SessionTicketKey leaks, previously recorded and future TLS
    // connections using that key might be compromised.
    SessionTicketKey [32]byte // Go 1.1

    // ClientSessionCache is a cache of ClientSessionState entries for TLS
    // session resumption. It is only used by clients.
    ClientSessionCache ClientSessionCache // Go 1.3

    // MinVersion contains the minimum SSL/TLS version that is acceptable.
    // If zero, then TLS 1.0 is taken as the minimum.
    MinVersion uint16 // Go 1.2

    // MaxVersion contains the maximum SSL/TLS version that is acceptable.
    // If zero, then the maximum version supported by this package is used,
    // which is currently TLS 1.3.
    MaxVersion uint16 // Go 1.2

    // CurvePreferences contains the elliptic curves that will be used in
    // an ECDHE handshake, in preference order. If empty, the default will
    // be used. The client will use the first preference as the type for
    // its key share in TLS 1.3. This may change in the future.
    CurvePreferences []CurveID // Go 1.3

    // DynamicRecordSizingDisabled disables adaptive sizing of TLS records.
    // When true, the largest possible TLS record size is always used. When
    // false, the size of TLS records may be adjusted in an attempt to
    // improve latency.
    DynamicRecordSizingDisabled bool // Go 1.7

    // Renegotiation controls what types of renegotiation are supported.
    // The default, none, is correct for the vast majority of applications.
    Renegotiation RenegotiationSupport // Go 1.7

    // KeyLogWriter optionally specifies a destination for TLS master secrets
    // in NSS key log format that can be used to allow external programs
    // such as Wireshark to decrypt TLS connections.
    // See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.
    // Use of KeyLogWriter compromises security and should only be
    // used for debugging.
    KeyLogWriter io.Writer // Go 1.8
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Config_keyLogWriter"> <span class="text">Example (KeyLogWriter)</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/tls"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
)

// zeroSource is an io.Reader that returns an unlimited number of zero bytes.
type zeroSource struct{}

func (zeroSource) Read(b []byte) (n int, err error) {
	for i := range b {
		b[i] = 0
	}

	return len(b), nil
}

func main() {
	// Debugging TLS applications by decrypting a network traffic capture.

	// WARNING: Use of KeyLogWriter compromises security and should only be
	// used for debugging.

	// Dummy test HTTP server for the example with insecure random so output is
	// reproducible.
	server := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
	server.TLS = &amp;tls.Config{
		Rand: zeroSource{}, // for example only; don't do this.
	}
	server.StartTLS()
	defer server.Close()

	// Typically the log would go to an open file:
	// w, err := os.OpenFile("tls-secrets.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	w := os.Stdout

	client := &amp;http.Client{
		Transport: &amp;http.Transport{
			TLSClientConfig: &amp;tls.Config{
				KeyLogWriter: w,

				Rand:               zeroSource{}, // for reproducible output; don't do this.
				InsecureSkipVerify: true,         // test server certificate is not trusted.
			},
		},
	}
	resp, err := client.Get(server.URL)
	if err != nil {
		log.Fatalf("Failed to get URL: %v", err)
	}
	resp.Body.Close()

	// The resulting file can be used with Wireshark to decrypt the TLS
	// connection by setting (Pre)-Master-Secret log filename in SSL Protocol
	// preferences.
}
</pre>   <h3 id="Config.BuildNameToCertificate">func (*Config) BuildNameToCertificate<a href="https://golang.org/src/crypto/tls/common.go?s=34698:34739#L940" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Config) BuildNameToCertificate()</pre> <p> BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates. </p> <h3 id="Config.Clone">func (*Config) Clone<a href="https://golang.org/src/crypto/tls/common.go?s=26487:26519#L649" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *Config) Clone() *Config</pre> <p> Clone returns a shallow clone of c. It is safe to clone a Config that is being used concurrently by a TLS client or server. </p> <h3 id="Config.SetSessionTicketKeys">func (*Config) SetSessionTicketKeys<a href="https://golang.org/src/crypto/tls/common.go?s=29607:29661#L737" class="source" target="_blank">Source</a>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</pre> <p> SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty. </p> <h2 id="Conn">type Conn<a href="https://golang.org/src/crypto/tls/conn.go?s=434:3993#L15" class="source" target="_blank">Source</a>  </h2> <p> A Conn represents a secured connection. It implements the net.Conn interface. </p> <pre data-language="go">type Conn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Client">func Client<a href="https://golang.org/src/crypto/tls/tls.go?s=1413:1461#L36" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Client(conn net.Conn, config *Config) *Conn</pre> <p> Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config. </p> <h3 id="Dial">func Dial<a href="https://golang.org/src/crypto/tls/tls.go?s=5164:5226#L166" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Dial(network, addr string, config *Config) (*Conn, error)</pre> <p> Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p>    <h4 id="example_Dial"> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/tls"
	"crypto/x509"
)

func main() {
	// Connecting with a custom root-certificate set.

	const rootPEM = `
-----BEGIN CERTIFICATE-----
MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG
EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7
qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD
VR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g
K4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI
KwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n
ZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB
BQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY
/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/
zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza
HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto
WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6
yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx
-----END CERTIFICATE-----`

	// First, create the set of root certificates. For this example we only
	// have one. It's also possible to omit this in order to use the
	// default root set of the current operating system.
	roots := x509.NewCertPool()
	ok := roots.AppendCertsFromPEM([]byte(rootPEM))
	if !ok {
		panic("failed to parse root certificate")
	}

	conn, err := tls.Dial("tcp", "mail.google.com:443", &amp;tls.Config{
		RootCAs: roots,
	})
	if err != nil {
		panic("failed to connect: " + err.Error())
	}
	conn.Close()
}
</pre>   <h3 id="DialWithDialer">func DialWithDialer<a href="https://golang.org/src/crypto/tls/tls.go?s=3510:3602#L95" class="source" target="_blank">Source</a>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</pre> <p> DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole. </p> <p> DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p> <h3 id="Server">func Server<a href="https://golang.org/src/crypto/tls/tls.go?s=1121:1169#L28" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func Server(conn net.Conn, config *Config) *Conn</pre> <p> Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p> <h3 id="Conn.Close">func (*Conn) Close<a href="https://golang.org/src/crypto/tls/conn.go?s=39450:39478#L1275" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) Close() error</pre> <p> Close closes the connection. </p> <h3 id="Conn.CloseWrite">func (*Conn) CloseWrite<a href="https://golang.org/src/crypto/tls/conn.go?s=40555:40588#L1314" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *Conn) CloseWrite() error</pre> <p> CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use Close. </p> <h3 id="Conn.ConnectionState">func (*Conn) ConnectionState<a href="https://golang.org/src/crypto/tls/conn.go?s=41859:41907#L1372" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) ConnectionState() ConnectionState</pre> <p> ConnectionState returns basic TLS details about the connection. </p> <h3 id="Conn.Handshake">func (*Conn) Handshake<a href="https://golang.org/src/crypto/tls/conn.go?s=41102:41134#L1337" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) Handshake() error</pre> <p> Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically. </p> <h3 id="Conn.LocalAddr">func (*Conn) LocalAddr<a href="https://golang.org/src/crypto/tls/conn.go?s=4156:4191#L108" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) LocalAddr() net.Addr</pre> <p> LocalAddr returns the local network address. </p> <h3 id="Conn.OCSPResponse">func (*Conn) OCSPResponse<a href="https://golang.org/src/crypto/tls/conn.go?s=42931:42967#L1409" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) OCSPResponse() []byte</pre> <p> OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.) </p> <h3 id="Conn.Read">func (*Conn) Read<a href="https://golang.org/src/crypto/tls/conn.go?s=38163:38205#L1231" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) Read(b []byte) (int, error)</pre> <p> Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline. </p> <h3 id="Conn.RemoteAddr">func (*Conn) RemoteAddr<a href="https://golang.org/src/crypto/tls/conn.go?s=4274:4310#L113" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) RemoteAddr() net.Addr</pre> <p> RemoteAddr returns the remote network address. </p> <h3 id="Conn.SetDeadline">func (*Conn) SetDeadline<a href="https://golang.org/src/crypto/tls/conn.go?s=4594:4639#L120" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) SetDeadline(t time.Time) error</pre> <p> SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p> <h3 id="Conn.SetReadDeadline">func (*Conn) SetReadDeadline<a href="https://golang.org/src/crypto/tls/conn.go?s=4799:4848#L126" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) SetReadDeadline(t time.Time) error</pre> <p> SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out. </p> <h3 id="Conn.SetWriteDeadline">func (*Conn) SetWriteDeadline<a href="https://golang.org/src/crypto/tls/conn.go?s=5122:5172#L133" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) SetWriteDeadline(t time.Time) error</pre> <p> SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p> <h3 id="Conn.VerifyHostname">func (*Conn) VerifyHostname<a href="https://golang.org/src/crypto/tls/conn.go?s=43226:43274#L1419" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) VerifyHostname(host string) error</pre> <p> VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem. </p> <h3 id="Conn.Write">func (*Conn) Write<a href="https://golang.org/src/crypto/tls/conn.go?s=34095:34138#L1071" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Conn) Write(b []byte) (int, error)</pre> <p> Write writes data to the connection. </p> <h2 id="ConnectionState">type ConnectionState<a href="https://golang.org/src/crypto/tls/common.go?s=6689:8406#L214" class="source" target="_blank">Source</a>  </h2> <p> ConnectionState records basic TLS details about the connection. </p> <pre data-language="go">type ConnectionState struct {
    Version                     uint16                // TLS version used by the connection (e.g. VersionTLS12); added in Go 1.3
    HandshakeComplete           bool                  // TLS handshake is complete
    DidResume                   bool                  // connection resumes a previous TLS connection; added in Go 1.1
    CipherSuite                 uint16                // cipher suite in use (TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, ...)
    NegotiatedProtocol          string                // negotiated next protocol (not guaranteed to be from Config.NextProtos)
    NegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server (client side only)
    ServerName                  string                // server name requested by client, if any (server side only)
    PeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer
    VerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates
    SignedCertificateTimestamps [][]byte              // SCTs from the peer, if any; added in Go 1.5
    OCSPResponse                []byte                // stapled OCSP response from peer, if any; added in Go 1.5

    // TLSUnique contains the "tls-unique" channel binding value (see RFC
    // 5929, section 3). For resumed sessions this value will be nil
    // because resumption does not include enough context (see
    // https://mitls.org/pages/attacks/3SHAKE#channelbindings). This will
    // change in future versions of Go once the TLS master-secret fix has
    // been standardized and implemented. It is not defined in TLS 1.3.
    TLSUnique []byte // Go 1.4
    // contains filtered or unexported fields
}
</pre> <h3 id="ConnectionState.ExportKeyingMaterial">func (*ConnectionState) ExportKeyingMaterial<a href="https://golang.org/src/crypto/tls/common.go?s=8692:8797#L243" class="source" target="_blank">Source</a>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)</pre> <p> ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error. </p> <h2 id="CurveID">type CurveID<a href="https://golang.org/src/crypto/tls/common.go?s=3396:3415#L103" class="source" target="_blank">Source</a>  <span title="Added in Go 1.3">1.3</span> </h2> <p> CurveID is the type of a TLS identifier for an elliptic curve. See <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8" target="_blank">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8</a>. </p> <p> In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7. </p> <pre data-language="go">type CurveID uint16</pre> <pre data-language="go">const (
    CurveP256 CurveID = 23
    CurveP384 CurveID = 24
    CurveP521 CurveID = 25
    X25519    CurveID = 29
)</pre> <h2 id="RecordHeaderError">type RecordHeaderError<a href="https://golang.org/src/crypto/tls/conn.go?s=17421:17892#L544" class="source" target="_blank">Source</a>  <span title="Added in Go 1.6">1.6</span> </h2> <p> RecordHeaderError is returned when a TLS record header is invalid. </p> <pre data-language="go">type RecordHeaderError struct {
    // Msg contains a human readable string that describes the error.
    Msg string
    // RecordHeader contains the five bytes of TLS record header that
    // triggered the error.
    RecordHeader [5]byte
    // Conn provides the underlying net.Conn in the case that a client
    // sent an initial handshake that didn't look like TLS.
    // It is nil if there's already been a handshake or a TLS alert has
    // been written to the connection.
    Conn net.Conn // Go 1.12
}
</pre> <h3 id="RecordHeaderError.Error">func (RecordHeaderError) Error<a href="https://golang.org/src/crypto/tls/conn.go?s=17894:17935#L557" class="source" target="_blank">Source</a>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (e RecordHeaderError) Error() string</pre> <h2 id="RenegotiationSupport">type RenegotiationSupport<a href="https://golang.org/src/crypto/tls/common.go?s=15715:15744#L409" class="source" target="_blank">Source</a>  <span title="Added in Go 1.7">1.7</span> </h2> <p> RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled. </p> <p> Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS. </p> <p> Renegotiation is not defined in TLS 1.3. </p> <pre data-language="go">type RenegotiationSupport int</pre> <pre data-language="go">const (
    // RenegotiateNever disables renegotiation.
    RenegotiateNever RenegotiationSupport = iota

    // RenegotiateOnceAsClient allows a remote server to request
    // renegotiation once per connection.
    RenegotiateOnceAsClient

    // RenegotiateFreelyAsClient allows a remote server to repeatedly
    // request renegotiation.
    RenegotiateFreelyAsClient
)</pre> <h2 id="SignatureScheme">type SignatureScheme<a href="https://golang.org/src/crypto/tls/common.go?s=11456:11483#L307" class="source" target="_blank">Source</a>  <span title="Added in Go 1.8">1.8</span> </h2> <p> SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3. </p> <pre data-language="go">type SignatureScheme uint16</pre> <pre data-language="go">const (
    // RSASSA-PKCS1-v1_5 algorithms.
    PKCS1WithSHA256 SignatureScheme = 0x0401
    PKCS1WithSHA384 SignatureScheme = 0x0501
    PKCS1WithSHA512 SignatureScheme = 0x0601

    // RSASSA-PSS algorithms with public key OID rsaEncryption.
    PSSWithSHA256 SignatureScheme = 0x0804
    PSSWithSHA384 SignatureScheme = 0x0805
    PSSWithSHA512 SignatureScheme = 0x0806

    // ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.
    ECDSAWithP256AndSHA256 SignatureScheme = 0x0403
    ECDSAWithP384AndSHA384 SignatureScheme = 0x0503
    ECDSAWithP521AndSHA512 SignatureScheme = 0x0603

    // EdDSA algorithms.
    Ed25519 SignatureScheme = 0x0807

    // Legacy signature and hash algorithms for TLS 1.2.
    PKCS1WithSHA1 SignatureScheme = 0x0201
    ECDSAWithSHA1 SignatureScheme = 0x0203
)</pre> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>
<a href="https://golang.org/src/crypto/tls/tls.go?s=472:742#L3" style="float: left;" target="_blank"></a> <p> The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf" target="_blank">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a> and <a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html" target="_blank">https://www.imperialviolet.org/2013/02/04/luckythirteen.html</a>. </p> </li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
     Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/crypto/tls/" class="_attribution-link" target="_blank">https://golang.org/pkg/crypto/tls/</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
