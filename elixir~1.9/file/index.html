
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>File - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" This module contains functions to manipulate files. ">
  <meta name="keywords" content="file, summary, types, encoding, mode, erlang, time, io, device, posix, stat, options, stream, functions, cd, path, cd!, function, chgrp, gid, chgrp!, chmod, chmod!, chown, uid, chown!, close, copy, source, destination, bytes, count, infinity, copy!, cp, callback, fn, -, true, end, cp!, r, r!, cwd, cwd!, dir, opts, exists, ln, existing, new, ln!, s, s!, ls, ls!, lstat, lstat!, mkdir, mkdir!, p, p!, open, modes, or, open!, read, read!, link, link!, regular, rename, rename!, rm, rm!, rf, rf!, rmdir, rmdir!, stat!, stream!, line, touch, system, os, second, touch!, write, content, write!, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/file/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  File  </h1>  <p>This module contains functions to manipulate files.</p> <p>Some of those functions are low-level, allowing the user to interact with files or IO devices, like <a href="#open/2"><code class="inline">open/2</code></a>, <a href="#copy/3"><code class="inline">copy/3</code></a> and others. This module also provides higher level functions that work with filenames and have their naming based on UNIX variants. For example, one can copy a file via <a href="#cp/3"><code class="inline">cp/3</code></a> and remove files and directories recursively via <a href="#rm_rf/1"><code class="inline">rm_rf/1</code></a>.</p> <p>Paths given to functions in this module can be either relative to the current working directory (as returned by <a href="../file/#cwd/0"><code class="inline">File.cwd/0</code></a>), or absolute paths. Shell conventions like <code class="inline">~</code> are not expanded automatically. To use paths like <code class="inline">~/Downloads</code>, you can use <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> or <a href="../path/#expand/2"><code class="inline">Path.expand/2</code></a> to expand your path to an absolute path.</p> <h2 id="module-encoding" class="section-heading">  Encoding </h2> <p>In order to write and read files, one must use the functions in the <a href="../io/"><code class="inline">IO</code></a> module. By default, a file is opened in binary mode, which requires the functions <a href="../io/#binread/2"><code class="inline">IO.binread/2</code></a> and <a href="../io/#binwrite/2"><code class="inline">IO.binwrite/2</code></a> to interact with the file. A developer may pass <code class="inline">:utf8</code> as an option when opening the file, then the slower <a href="../io/#read/2"><code class="inline">IO.read/2</code></a> and <a href="../io/#write/2"><code class="inline">IO.write/2</code></a> functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</p> <p>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.</p> <h2 id="module-api" class="section-heading">  API </h2> <p>Most of the functions in this module return <code class="inline">:ok</code> or <code class="inline">{:ok, result}</code> in case of success, <code class="inline">{:error, reason}</code> otherwise. Those functions also have a variant that ends with <code class="inline">!</code> which returns the result (instead of the <code class="inline">{:ok, result}</code> tuple) in case of success or raises an exception in case it fails. For example:</p> <pre data-language="elixir">File.read("hello.txt")
#=&gt; {:ok, "World"}

File.read("invalid.txt")
#=&gt; {:error, :enoent}

File.read!("hello.txt")
#=&gt; "World"

File.read!("invalid.txt")
#=&gt; raises File.Error</pre> <p>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</p> <h2 id="module-processes-and-raw-files" class="section-heading">  Processes and raw files </h2> <p>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</p> <p>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</p> <p>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in <code class="inline">:raw</code> mode. The options <code class="inline">:read_ahead</code> and <code class="inline">:delayed_write</code> are also useful when operating on large files or working with files in tight loops.</p> <p>Check <a href="http://www.erlang.org/doc/man/file.html#open-2" target="_blank"><code class="inline">:file.open/2</code></a> for more information about such options and other performance considerations.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:encoding_mode/0">encoding_mode()</a> </dt>   <dt class="summary-signature"> <a href="#t:erlang_time/0">erlang_time()</a> </dt>   <dt class="summary-signature"> <a href="#t:io_device/0">io_device()</a> </dt>   <dt class="summary-signature"> <a href="#t:mode/0">mode()</a> </dt>   <dt class="summary-signature"> <a href="#t:posix/0">posix()</a> </dt>   <dt class="summary-signature"> <a href="#t:posix_time/0">posix_time()</a> </dt>   <dt class="summary-signature"> <a href="#t:stat_options/0">stat_options()</a> </dt>   <dt class="summary-signature"> <a href="#t:stream_mode/0">stream_mode()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#cd/1">cd(path)</a> </dt> <dd class="summary-synopsis"><p>Sets the current working directory.</p></dd>   <dt class="summary-signature"> <a href="#cd!/1">cd!(path)</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#cd/1"><code class="inline">cd/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails.</p></dd>   <dt class="summary-signature"> <a href="#cd!/2">cd!(path, function)</a> </dt> <dd class="summary-synopsis"><p>Changes the current directory to the given <code class="inline">path</code>, executes the given function and then reverts back to the previous path regardless of whether there is an exception.</p></dd>   <dt class="summary-signature"> <a href="#chgrp/2">chgrp(path, gid)</a> </dt> <dd class="summary-synopsis"><p>Changes the group given by the group ID <code class="inline">gid</code> for a given <code class="inline">file</code>. Returns <code class="inline">:ok</code> on success, or <code class="inline">{:error, reason}</code> on failure.</p></dd>   <dt class="summary-signature"> <a href="#chgrp!/2">chgrp!(path, gid)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#chgrp/2"><code class="inline">chgrp/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#chmod/2">chmod(path, mode)</a> </dt> <dd class="summary-synopsis"><p>Changes the <code class="inline">mode</code> for a given <code class="inline">file</code>.</p></dd>   <dt class="summary-signature"> <a href="#chmod!/2">chmod!(path, mode)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#chmod/2"><code class="inline">chmod/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#chown/2">chown(path, uid)</a> </dt> <dd class="summary-synopsis"><p>Changes the owner given by the user ID <code class="inline">uid</code> for a given <code class="inline">file</code>. Returns <code class="inline">:ok</code> on success, or <code class="inline">{:error, reason}</code> on failure.</p></dd>   <dt class="summary-signature"> <a href="#chown!/2">chown!(path, uid)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#chown/2"><code class="inline">chown/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#close/1">close(io_device)</a> </dt> <dd class="summary-synopsis"><p>Closes the file referenced by <code class="inline">io_device</code>. It mostly returns <code class="inline">:ok</code>, except for some severe errors such as out of memory.</p></dd>   <dt class="summary-signature"> <a href="#copy/3">copy(source, destination, bytes_count \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Copies the contents of <code class="inline">source</code> to <code class="inline">destination</code>.</p></dd>   <dt class="summary-signature"> <a href="#copy!/3">copy!(source, destination, bytes_count \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#copy/3"><code class="inline">copy/3</code></a> but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns the <code class="inline">bytes_copied</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#cp/3">cp(source_file, destination_file, callback \\ fn _, _ -&gt; true end)</a> </dt> <dd class="summary-synopsis"><p>Copies the contents in <code class="inline">source_file</code> to <code class="inline">destination_file</code> preserving its modes.</p></dd>   <dt class="summary-signature"> <a href="#cp!/3">cp!(source_file, destination_file, callback \\ fn _, _ -&gt; true end)</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#cp/3"><code class="inline">cp/3</code></a>, but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#cp_r/3">cp_r(source, destination, callback \\ fn _, _ -&gt; true end)</a> </dt> <dd class="summary-synopsis"><p>Copies the contents in <code class="inline">source</code> to <code class="inline">destination</code> recursively, maintaining the source directory structure and modes.</p></dd>   <dt class="summary-signature"> <a href="#cp_r!/3">cp_r!(source, destination, callback \\ fn _, _ -&gt; true end)</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#cp_r/3"><code class="inline">cp_r/3</code></a>, but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns the list of copied files otherwise.</p></dd>   <dt class="summary-signature"> <a href="#cwd/0">cwd()</a> </dt> <dd class="summary-synopsis"><p>Gets the current working directory.</p></dd>   <dt class="summary-signature"> <a href="#cwd!/0">cwd!()</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#cwd/0"><code class="inline">cwd/0</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails.</p></dd>   <dt class="summary-signature"> <a href="#dir?/2">dir?(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given path is a directory.</p></dd>   <dt class="summary-signature"> <a href="#exists?/2">exists?(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given path exists.</p></dd>   <dt class="summary-signature"> <a href="#ln/2">ln(existing, new)</a> </dt> <dd class="summary-synopsis"><p>Creates a hard link <code class="inline">new</code> to the file <code class="inline">existing</code>.</p></dd>   <dt class="summary-signature"> <a href="#ln!/2">ln!(existing, new)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#ln/2"><code class="inline">ln/2</code></a> but raises a <a href="../file.linkerror/"><code class="inline">File.LinkError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#ln_s/2">ln_s(existing, new)</a> </dt> <dd class="summary-synopsis"><p>Creates a symbolic link <code class="inline">new</code> to the file or directory <code class="inline">existing</code>.</p></dd>   <dt class="summary-signature"> <a href="#ln_s!/2">ln_s!(existing, new)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#ln_s/2"><code class="inline">ln_s/2</code></a> but raises a <a href="../file.linkerror/"><code class="inline">File.LinkError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#ls/1">ls(path \\ ".")</a> </dt> <dd class="summary-synopsis"><p>Returns the list of files in the given directory.</p></dd>   <dt class="summary-signature"> <a href="#ls!/1">ls!(path \\ ".")</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#ls/1"><code class="inline">ls/1</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of an error.</p></dd>   <dt class="summary-signature"> <a href="#lstat/2">lstat(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns information about the <code class="inline">path</code>. If the file is a symlink, sets the <code class="inline">type</code> to <code class="inline">:symlink</code> and returns a <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct for the link. For any other file, returns exactly the same values as <a href="#stat/2"><code class="inline">stat/2</code></a>.</p></dd>   <dt class="summary-signature"> <a href="#lstat!/2">lstat!(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#lstat/2"><code class="inline">lstat/2</code></a> but returns the <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p></dd>   <dt class="summary-signature"> <a href="#mkdir/1">mkdir(path)</a> </dt> <dd class="summary-synopsis"><p>Tries to create the directory <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#mkdir!/1">mkdir!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#mkdir/1"><code class="inline">mkdir/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#mkdir_p/1">mkdir_p(path)</a> </dt> <dd class="summary-synopsis"><p>Tries to create the directory <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#mkdir_p!/1">mkdir_p!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#mkdir_p/1"><code class="inline">mkdir_p/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#open/2">open(path, modes_or_function \\ [])</a> </dt> <dd class="summary-synopsis"><p>Opens the given <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#open/3">open(path, modes, function)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#open/2"><code class="inline">open/2</code></a> but expects a function as its last argument.</p></dd>   <dt class="summary-signature"> <a href="#open!/2">open!(path, modes_or_function \\ [])</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#open/2"><code class="inline">open/2</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if the file could not be opened. Returns the IO device otherwise.</p></dd>   <dt class="summary-signature"> <a href="#open!/3">open!(path, modes, function)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#open/3"><code class="inline">open/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if the file could not be opened.</p></dd>   <dt class="summary-signature"> <a href="#read/1">read(path)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">{:ok, binary}</code>, where <code class="inline">binary</code> is a binary data object that contains the contents of <code class="inline">path</code>, or <code class="inline">{:error, reason}</code> if an error occurs.</p></dd>   <dt class="summary-signature"> <a href="#read!/1">read!(path)</a> </dt> <dd class="summary-synopsis"><p>Returns a binary with the contents of the given filename, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error occurs.</p></dd>   <dt class="summary-signature"> <a href="#read_link/1">read_link(path)</a> </dt> <dd class="summary-synopsis"><p>Reads the symbolic link at <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#read_link!/1">read_link!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#read_link/1"><code class="inline">read_link/1</code></a> but returns the target directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p></dd>   <dt class="summary-signature"> <a href="#regular?/2">regular?(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the path is a regular file.</p></dd>   <dt class="summary-signature"> <a href="#rename/2">rename(source, destination)</a> </dt> <dd class="summary-synopsis"><p>Renames the <code class="inline">source</code> file to <code class="inline">destination</code> file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the <code class="inline">destination</code> filename, it is not sufficient to simply specify its directory.</p></dd>   <dt class="summary-signature"> <a href="#rename!/2">rename!(source, destination)</a> </dt> <dd class="summary-synopsis"><p>The same as <a href="#rename/2"><code class="inline">rename/2</code></a> but raises a <a href="../file.renameerror/"><code class="inline">File.RenameError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#rm/1">rm(path)</a> </dt> <dd class="summary-synopsis"><p>Tries to delete the file <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#rm!/1">rm!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#rm/1"><code class="inline">rm/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#rm_rf/1">rm_rf(path)</a> </dt> <dd class="summary-synopsis"><p>Removes files and directories recursively at the given <code class="inline">path</code>. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</p></dd>   <dt class="summary-signature"> <a href="#rm_rf!/1">rm_rf!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#rm_rf/1"><code class="inline">rm_rf/1</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failures, otherwise the list of files or directories removed.</p></dd>   <dt class="summary-signature"> <a href="#rmdir/1">rmdir(path)</a> </dt> <dd class="summary-synopsis"><p>Tries to delete the dir at <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#rmdir!/1">rmdir!(path)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#rmdir/1"><code class="inline">rmdir/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p></dd>   <dt class="summary-signature"> <a href="#stat/2">stat(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns information about the <code class="inline">path</code>. If it exists, it returns a <code class="inline">{:ok, info}</code> tuple, where info is a <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct. Returns <code class="inline">{:error, reason}</code> with the same reasons as <a href="#read/1"><code class="inline">read/1</code></a> if a failure occurs.</p></dd>   <dt class="summary-signature"> <a href="#stat!/2">stat!(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#stat/2"><code class="inline">stat/2</code></a> but returns the <a href="../file.stat/"><code class="inline">File.Stat</code></a> directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p></dd>   <dt class="summary-signature"> <a href="#stream!/3">stream!(path, modes \\ [], line_or_bytes \\ :line)</a> </dt> <dd class="summary-synopsis"><p>Returns a <a href="../file.stream/"><code class="inline">File.Stream</code></a> for the given <code class="inline">path</code> with the given <code class="inline">modes</code>.</p></dd>   <dt class="summary-signature"> <a href="#touch/2">touch(path, time \\ System.os_time(:second))</a> </dt> <dd class="summary-synopsis"><p>Updates modification time (mtime) and access time (atime) of the given file.</p></dd>   <dt class="summary-signature"> <a href="#touch!/2">touch!(path, time \\ System.os_time(:second))</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#touch/2"><code class="inline">touch/2</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#write/3">write(path, content, modes \\ [])</a> </dt> <dd class="summary-synopsis"><p>Writes <code class="inline">content</code> to the file <code class="inline">path</code>.</p></dd>   <dt class="summary-signature"> <a href="#write!/3">write!(path, content, modes \\ [])</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#write/3"><code class="inline">write/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#write_stat/3">write_stat(path, stat, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Writes the given <a href="../file.stat/"><code class="inline">File.Stat</code></a> back to the file system at the given path. Returns <code class="inline">:ok</code> or <code class="inline">{:error, reason}</code>.</p></dd>   <dt class="summary-signature"> <a href="#write_stat!/3">write_stat!(path, stat, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#write_stat/3"><code class="inline">write_stat/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:encoding_mode/0">  <h1 class="signature">encoding_mode()</h1>     </h3>
<pre data-language="elixir">encoding_mode() ::
  :utf8
  | {:encoding,
     :latin1
     | :unicode
     | :utf8
     | :utf16
     | :utf32
     | {:utf16, :big | :little}
     | {:utf32, :big | :little}}</pre>     <h3 class="detail-header type" id="t:erlang_time/0">  <h1 class="signature">erlang_time()</h1>     </h3>
<pre data-language="elixir">erlang_time() ::
  {{year :: non_neg_integer(), month :: 1..12, day :: 1..31},
   {hour :: 0..23, minute :: 0..59, second :: 0..59}}</pre>     <h3 class="detail-header type" id="t:io_device/0">  <h1 class="signature">io_device()</h1>     </h3>
<pre data-language="elixir">io_device() :: :file.io_device()</pre>     <h3 class="detail-header type" id="t:mode/0">  <h1 class="signature">mode()</h1>     </h3>
<pre data-language="elixir">mode() ::
  :append
  | :binary
  | :charlist
  | :compressed
  | :delayed_write
  | :exclusive
  | :raw
  | :read
  | :read_ahead
  | :sync
  | :write
  | {:read_ahead, pos_integer()}
  | {:delayed_write, non_neg_integer(), non_neg_integer()}
  | encoding_mode()</pre>     <h3 class="detail-header type" id="t:posix/0">  <h1 class="signature">posix()</h1>     </h3>
<pre data-language="elixir">posix() :: :file.posix()</pre>     <h3 class="detail-header type" id="t:posix_time/0">  <h1 class="signature">posix_time()</h1>     </h3>
<pre data-language="elixir">posix_time() :: integer()</pre>     <h3 class="detail-header type" id="t:stat_options/0">  <h1 class="signature">stat_options()</h1>     </h3>
<pre data-language="elixir">stat_options() :: [{:time, :local | :universal | :posix}]</pre>     <h3 class="detail-header type" id="t:stream_mode/0">  <h1 class="signature">stream_mode()</h1>     </h3>
<pre data-language="elixir">stream_mode() ::
  encoding_mode()
  | :trim_bom
  | {:read_ahead, pos_integer() | false}
  | {:delayed_write, non_neg_integer(), non_neg_integer()}</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="cd/1">  <h1 class="signature">cd(path)</h1>     </h3>
<pre data-language="elixir">cd(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Sets the current working directory.</p> <p>Returns <code class="inline">:ok</code> if successful, <code class="inline">{:error, reason}</code> otherwise.</p>    <h3 class="detail-header function" id="cd!/1">  <h1 class="signature">cd!(path)</h1>     </h3>
<pre data-language="elixir">cd!(Path.t()) :: :ok</pre>  <p>The same as <a href="#cd/1"><code class="inline">cd/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails.</p>    <h3 class="detail-header function" id="cd!/2">  <h1 class="signature">cd!(path, function)</h1>     </h3>
<pre data-language="elixir">cd!(Path.t(), (() -&gt; res)) :: res when res: var</pre>  <p>Changes the current directory to the given <code class="inline">path</code>, executes the given function and then reverts back to the previous path regardless of whether there is an exception.</p> <p>Raises an error if retrieving or changing the current directory fails.</p>    <h3 class="detail-header function" id="chgrp/2">  <h1 class="signature">chgrp(path, gid)</h1>     </h3>
<pre data-language="elixir">chgrp(Path.t(), non_neg_integer()) :: :ok | {:error, posix()}</pre>  <p>Changes the group given by the group ID <code class="inline">gid</code> for a given <code class="inline">file</code>. Returns <code class="inline">:ok</code> on success, or <code class="inline">{:error, reason}</code> on failure.</p>    <h3 class="detail-header function" id="chgrp!/2">  <h1 class="signature">chgrp!(path, gid)</h1>     </h3>
<pre data-language="elixir">chgrp!(Path.t(), non_neg_integer()) :: :ok</pre>  <p>Same as <a href="#chgrp/2"><code class="inline">chgrp/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>    <h3 class="detail-header function" id="chmod/2">  <h1 class="signature">chmod(path, mode)</h1>     </h3>
<pre data-language="elixir">chmod(Path.t(), non_neg_integer()) :: :ok | {:error, posix()}</pre>  <p>Changes the <code class="inline">mode</code> for a given <code class="inline">file</code>.</p> <p>Returns <code class="inline">:ok</code> on success, or <code class="inline">{:error, reason}</code> on failure.</p> <h4 id="chmod/2-permissions" class="section-heading">  Permissions </h4> <p>File permissions are specified by adding together the following octal modes:</p> <ul> <li>
<p><code class="inline">0o400</code> - read permission: owner</p> </li> <li>
<p><code class="inline">0o200</code> - write permission: owner</p> </li> <li>
<p><code class="inline">0o100</code> - execute permission: owner</p> </li> <li>
<p><code class="inline">0o040</code> - read permission: group</p> </li> <li>
<p><code class="inline">0o020</code> - write permission: group</p> </li> <li>
<p><code class="inline">0o010</code> - execute permission: group</p> </li> <li>
<p><code class="inline">0o004</code> - read permission: other</p> </li> <li>
<p><code class="inline">0o002</code> - write permission: other</p> </li> <li>
<p><code class="inline">0o001</code> - execute permission: other</p> </li> </ul> <p>For example, setting the mode <code class="inline">0o755</code> gives it write, read and execute permission to the owner and both read and execute permission to group and others.</p>    <h3 class="detail-header function" id="chmod!/2">  <h1 class="signature">chmod!(path, mode)</h1>     </h3>
<pre data-language="elixir">chmod!(Path.t(), non_neg_integer()) :: :ok</pre>  <p>Same as <a href="#chmod/2"><code class="inline">chmod/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>    <h3 class="detail-header function" id="chown/2">  <h1 class="signature">chown(path, uid)</h1>     </h3>
<pre data-language="elixir">chown(Path.t(), non_neg_integer()) :: :ok | {:error, posix()}</pre>  <p>Changes the owner given by the user ID <code class="inline">uid</code> for a given <code class="inline">file</code>. Returns <code class="inline">:ok</code> on success, or <code class="inline">{:error, reason}</code> on failure.</p>    <h3 class="detail-header function" id="chown!/2">  <h1 class="signature">chown!(path, uid)</h1>     </h3>
<pre data-language="elixir">chown!(Path.t(), non_neg_integer()) :: :ok</pre>  <p>Same as <a href="#chown/2"><code class="inline">chown/2</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>    <h3 class="detail-header function" id="close/1">  <h1 class="signature">close(io_device)</h1>     </h3>
<pre data-language="elixir">close(io_device()) :: :ok | {:error, posix() | :badarg | :terminated}</pre>  <p>Closes the file referenced by <code class="inline">io_device</code>. It mostly returns <code class="inline">:ok</code>, except for some severe errors such as out of memory.</p> <p>Note that if the option <code class="inline">:delayed_write</code> was used when opening the file, <a href="#close/1"><code class="inline">close/1</code></a> might return an old write error and not even try to close the file. See <a href="#open/2"><code class="inline">open/2</code></a> for more information.</p>     <h3 class="detail-header function" id="copy/3">  <h1 class="signature">copy(source, destination, bytes_count \\ :infinity)</h1>     </h3>
<pre data-language="elixir">copy(Path.t() | io_device(), Path.t() | io_device(), pos_integer() | :infinity) ::
  {:ok, non_neg_integer()} | {:error, posix()}</pre>  <p>Copies the contents of <code class="inline">source</code> to <code class="inline">destination</code>.</p> <p>Both parameters can be a filename or an IO device opened with <a href="#open/2"><code class="inline">open/2</code></a>. <code class="inline">bytes_count</code> specifies the number of bytes to copy, the default being <code class="inline">:infinity</code>.</p> <p>If file <code class="inline">destination</code> already exists, it is overwritten by the contents in <code class="inline">source</code>.</p> <p>Returns <code class="inline">{:ok, bytes_copied}</code> if successful, <code class="inline">{:error, reason}</code> otherwise.</p> <p>Compared to the <a href="#cp/3"><code class="inline">cp/3</code></a>, this function is more low-level, allowing a copy from device to device limited by a number of bytes. On the other hand, <a href="#cp/3"><code class="inline">cp/3</code></a> performs more extensive checks on both source and destination and it also preserves the file mode after copy.</p> <p>Typical error reasons are the same as in <a href="#open/2"><code class="inline">open/2</code></a>, <a href="#read/1"><code class="inline">read/1</code></a> and <a href="#write/3"><code class="inline">write/3</code></a>.</p>     <h3 class="detail-header function" id="copy!/3">  <h1 class="signature">copy!(source, destination, bytes_count \\ :infinity)</h1>     </h3>
<pre data-language="elixir">copy!(Path.t() | io_device(), Path.t() | io_device(), pos_integer() | :infinity) ::
  non_neg_integer()</pre>  <p>The same as <a href="#copy/3"><code class="inline">copy/3</code></a> but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns the <code class="inline">bytes_copied</code> otherwise.</p>     <h3 class="detail-header function" id="cp/3">  <h1 class="signature">cp(source_file, destination_file, callback \\ fn _, _ -&gt; true end)</h1>     </h3>
<pre data-language="elixir">cp(Path.t(), Path.t(), (Path.t(), Path.t() -&gt; boolean())) ::
  :ok | {:error, posix()}</pre>  <p>Copies the contents in <code class="inline">source_file</code> to <code class="inline">destination_file</code> preserving its modes.</p> <p><code class="inline">source_file</code> and <code class="inline">destination_file</code> must be a file or a symbolic link to one, or in the case of destination, a path to a non-existent file. If either one of them is a directory, <code class="inline">{:error, :eisdir}</code> will be returned.</p> <p>If a file already exists in the destination, it invokes a callback which should return <code class="inline">true</code> if the existing file should be overwritten, <code class="inline">false</code> otherwise. The callback defaults to return <code class="inline">true</code>.</p> <p>The function returns <code class="inline">:ok</code> in case of success. Otherwise, it returns <code class="inline">{:error, reason}</code>.</p> <p>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check <a href="#copy/3"><code class="inline">copy/3</code></a> instead.</p> <p>Note: The command <code class="inline">cp</code> in Unix systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</p>     <h3 class="detail-header function" id="cp!/3">  <h1 class="signature">cp!(source_file, destination_file, callback \\ fn _, _ -&gt; true end)</h1>     </h3>
<pre data-language="elixir">cp!(Path.t(), Path.t(), (Path.t(), Path.t() -&gt; boolean())) :: :ok</pre>  <p>The same as <a href="#cp/3"><code class="inline">cp/3</code></a>, but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>     <h3 class="detail-header function" id="cp_r/3">  <h1 class="signature">cp_r(source, destination, callback \\ fn _, _ -&gt; true end)</h1>     </h3>
<pre data-language="elixir">cp_r(Path.t(), Path.t(), (Path.t(), Path.t() -&gt; boolean())) ::
  {:ok, [binary()]} | {:error, posix(), binary()}</pre>  <p>Copies the contents in <code class="inline">source</code> to <code class="inline">destination</code> recursively, maintaining the source directory structure and modes.</p> <p>If <code class="inline">source</code> is a file or a symbolic link to it, <code class="inline">destination</code> must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</p> <p>If <code class="inline">source</code> is a directory, or a symbolic link to it, then <code class="inline">destination</code> must be an existent <code class="inline">directory</code> or a symbolic link to one, or a path to a non-existent directory.</p> <p>If the source is a file, it copies <code class="inline">source</code> to <code class="inline">destination</code>. If the <code class="inline">source</code> is a directory, it copies the contents inside source into the <code class="inline">destination</code> directory.</p> <p>If a file already exists in the destination, it invokes <code class="inline">callback</code>. <code class="inline">callback</code> must be a function that takes two arguments: <code class="inline">source</code> and <code class="inline">destination</code>. The callback should return <code class="inline">true</code> if the existing file should be overwritten and <code class="inline">false</code> otherwise.</p> <p>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed.</p> <p>The function returns <code class="inline">{:ok, files_and_directories}</code> in case of success, <code class="inline">files_and_directories</code> lists all files and directories copied in no specific order. It returns <code class="inline">{:error, reason, file}</code> otherwise.</p> <p>Note: The command <code class="inline">cp</code> in Unix systems behaves differently depending on whether <code class="inline">destination</code> is an existing directory or not. We have chosen to explicitly disallow this behaviour. If <code class="inline">source</code> is a <code class="inline">file</code> and <code class="inline">destination</code> is a directory, <code class="inline">{:error, :eisdir}</code> will be returned.</p> <h4 id="cp_r/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Copies file "a.txt" to "b.txt"
File.cp_r("a.txt", "b.txt")

# Copies all files in "samples" to "tmp"
File.cp_r("samples", "tmp")

# Same as before, but asks the user how to proceed in case of conflicts
File.cp_r("samples", "tmp", fn source, destination -&gt;
  IO.gets("Overwriting #{destination} by #{source}. Type y to confirm. ") == "y\n"
end)</pre>     <h3 class="detail-header function" id="cp_r!/3">  <h1 class="signature">cp_r!(source, destination, callback \\ fn _, _ -&gt; true end)</h1>     </h3>
<pre data-language="elixir">cp_r!(Path.t(), Path.t(), (Path.t(), Path.t() -&gt; boolean())) :: [binary()]</pre>  <p>The same as <a href="#cp_r/3"><code class="inline">cp_r/3</code></a>, but raises a <a href="../file.copyerror/"><code class="inline">File.CopyError</code></a> exception if it fails. Returns the list of copied files otherwise.</p>    <h3 class="detail-header function" id="cwd/0">  <h1 class="signature">cwd()</h1>     </h3>
<pre data-language="elixir">cwd() :: {:ok, binary()} | {:error, posix()}</pre>  <p>Gets the current working directory.</p> <p>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns <code class="inline">{:ok, cwd}</code> in case of success, <code class="inline">{:error, reason}</code> otherwise.</p>    <h3 class="detail-header function" id="cwd!/0">  <h1 class="signature">cwd!()</h1>     </h3>
<pre data-language="elixir">cwd!() :: binary()</pre>  <p>The same as <a href="#cwd/0"><code class="inline">cwd/0</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails.</p>     <h3 class="detail-header function" id="dir?/2">  <h1 class="signature">dir?(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">dir?(Path.t(), [dir_option]) :: boolean() when dir_option: :raw</pre>  <p>Returns <code class="inline">true</code> if the given path is a directory.</p> <p>This function follows symbolic links, so if a symbolic link points to a directory, <code class="inline">true</code> is returned.</p> <h4 id="dir?/2-options" class="section-heading">  Options </h4> <p>The supported options are:</p> <ul> <li>
<code class="inline">:raw</code> - a single atom to bypass the file server and only check for the file locally </li> </ul> <h4 id="dir?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.dir?("./test")
#=&gt; true

File.dir?("test")
#=&gt; true

File.dir?("/usr/bin")
#=&gt; true

File.dir?("~/Downloads")
#=&gt; false

"~/Downloads" |&gt; Path.expand() |&gt; File.dir?()
#=&gt; true</pre>     <h3 class="detail-header function" id="exists?/2">  <h1 class="signature">exists?(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">exists?(Path.t(), [exists_option]) :: boolean() when exists_option: :raw</pre>  <p>Returns <code class="inline">true</code> if the given path exists.</p> <p>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns <code class="inline">false</code> for symbolic links pointing to non-existing targets.</p> <h4 id="exists?/2-options" class="section-heading">  Options </h4> <p>The supported options are:</p> <ul> <li>
<code class="inline">:raw</code> - a single atom to bypass the file server and only check for the file locally </li> </ul> <h4 id="exists?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.exists?("test/")
#=&gt; true

File.exists?("missing.txt")
#=&gt; false

File.exists?("/dev/null")
#=&gt; true</pre>    <h3 class="detail-header function" id="ln/2">  <h1 class="signature">ln(existing, new)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">ln(Path.t(), Path.t()) :: :ok | {:error, posix()}</pre>  <p>Creates a hard link <code class="inline">new</code> to the file <code class="inline">existing</code>.</p> <p>Returns <code class="inline">:ok</code> if successful, <code class="inline">{:error, reason}</code> otherwise. If the operating system does not support hard links, returns <code class="inline">{:error, :enotsup}</code>.</p>    <h3 class="detail-header function" id="ln!/2">  <h1 class="signature">ln!(existing, new)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">ln!(Path.t(), Path.t()) :: :ok</pre>  <p>Same as <a href="#ln/2"><code class="inline">ln/2</code></a> but raises a <a href="../file.linkerror/"><code class="inline">File.LinkError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>    <h3 class="detail-header function" id="ln_s/2">  <h1 class="signature">ln_s(existing, new)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">ln_s(Path.t(), Path.t()) :: :ok | {:error, posix()}</pre>  <p>Creates a symbolic link <code class="inline">new</code> to the file or directory <code class="inline">existing</code>.</p> <p>Returns <code class="inline">:ok</code> if successful, <code class="inline">{:error, reason}</code> otherwise. If the operating system does not support symlinks, returns <code class="inline">{:error, :enotsup}</code>.</p>    <h3 class="detail-header function" id="ln_s!/2">  <h1 class="signature">ln_s!(existing, new)</h1>     </h3>
<pre data-language="elixir">ln_s!(Path.t(), Path.t()) :: :ok</pre>  <p>Same as <a href="#ln_s/2"><code class="inline">ln_s/2</code></a> but raises a <a href="../file.linkerror/"><code class="inline">File.LinkError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>     <h3 class="detail-header function" id="ls/1">  <h1 class="signature">ls(path \\ ".")</h1>     </h3>
<pre data-language="elixir">ls(Path.t()) :: {:ok, [binary()]} | {:error, posix()}</pre>  <p>Returns the list of files in the given directory.</p> <p>Returns <code class="inline">{:ok, files}</code> in case of success, <code class="inline">{:error, reason}</code> otherwise.</p>     <h3 class="detail-header function" id="ls!/1">  <h1 class="signature">ls!(path \\ ".")</h1>     </h3>
<pre data-language="elixir">ls!(Path.t()) :: [binary()]</pre>  <p>The same as <a href="#ls/1"><code class="inline">ls/1</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of an error.</p>     <h3 class="detail-header function" id="lstat/2">  <h1 class="signature">lstat(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">lstat(Path.t(), stat_options()) :: {:ok, File.Stat.t()} | {:error, posix()}</pre>  <p>Returns information about the <code class="inline">path</code>. If the file is a symlink, sets the <code class="inline">type</code> to <code class="inline">:symlink</code> and returns a <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct for the link. For any other file, returns exactly the same values as <a href="#stat/2"><code class="inline">stat/2</code></a>.</p> <p>For more details, see <a href="http://www.erlang.org/doc/man/file.html#read_link_info-2" target="_blank"><code class="inline">:file.read_link_info/2</code></a>.</p> <h4 id="lstat/2-options" class="section-heading">  Options </h4> <p>The accepted options are:</p> <ul> <li>
<code class="inline">:time</code> - configures how the file timestamps are returned </li> </ul> <p>The values for <code class="inline">:time</code> can be:</p> <ul> <li>
<code class="inline">:universal</code> - returns a <code class="inline">{date, time}</code> tuple in UTC (default) </li> <li>
<code class="inline">:local</code> - returns a <code class="inline">{date, time}</code> tuple using the machine time </li> <li>
<code class="inline">:posix</code> - returns the time as integer seconds since epoch </li> </ul> <p>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the <code class="inline">time: :posix</code> option.</p>     <h3 class="detail-header function" id="lstat!/2">  <h1 class="signature">lstat!(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">lstat!(Path.t(), stat_options()) :: File.Stat.t()</pre>  <p>Same as <a href="#lstat/2"><code class="inline">lstat/2</code></a> but returns the <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p>    <h3 class="detail-header function" id="mkdir/1">  <h1 class="signature">mkdir(path)</h1>     </h3>
<pre data-language="elixir">mkdir(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Tries to create the directory <code class="inline">path</code>.</p> <p>Missing parent directories are not created. Returns <code class="inline">:ok</code> if successful, or <code class="inline">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons are:</p> <ul> <li>
<code class="inline">:eacces</code> - missing search or write permissions for the parent directories of <code class="inline">path</code> </li> <li>
<code class="inline">:eexist</code> - there is already a file or directory named <code class="inline">path</code> </li> <li>
<code class="inline">:enoent</code> - a component of <code class="inline">path</code> does not exist </li> <li>
<code class="inline">:enospc</code> - there is no space left on the device </li> <li>
<code class="inline">:enotdir</code> - a component of <code class="inline">path</code> is not a directory; on some platforms, <code class="inline">:enoent</code> is returned instead </li> </ul>    <h3 class="detail-header function" id="mkdir!/1">  <h1 class="signature">mkdir!(path)</h1>     </h3>
<pre data-language="elixir">mkdir!(Path.t()) :: :ok</pre>  <p>Same as <a href="#mkdir/1"><code class="inline">mkdir/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>    <h3 class="detail-header function" id="mkdir_p/1">  <h1 class="signature">mkdir_p(path)</h1>     </h3>
<pre data-language="elixir">mkdir_p(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Tries to create the directory <code class="inline">path</code>.</p> <p>Missing parent directories are created. Returns <code class="inline">:ok</code> if successful, or <code class="inline">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons are:</p> <ul> <li>
<code class="inline">:eacces</code> - missing search or write permissions for the parent directories of <code class="inline">path</code> </li> <li>
<code class="inline">:enospc</code> - there is no space left on the device </li> <li>
<code class="inline">:enotdir</code> - a component of <code class="inline">path</code> is not a directory </li> </ul>    <h3 class="detail-header function" id="mkdir_p!/1">  <h1 class="signature">mkdir_p!(path)</h1>     </h3>
<pre data-language="elixir">mkdir_p!(Path.t()) :: :ok</pre>  <p>Same as <a href="#mkdir_p/1"><code class="inline">mkdir_p/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>     <h3 class="detail-header function" id="open/2">  <h1 class="signature">open(path, modes_or_function \\ [])</h1>      </h3>
<pre data-language="elixir">open(Path.t(), (io_device() -&gt; res)) :: {:ok, res} | {:error, posix()}
when res: var</pre>
<pre data-language="elixir">open(Path.t(), [mode() | :ram]) :: {:ok, io_device()} | {:error, posix()}</pre>  <p>Opens the given <code class="inline">path</code>.</p> <p>In order to write and read files, one must use the functions in the <a href="../io/"><code class="inline">IO</code></a> module. By default, a file is opened in <code class="inline">:binary</code> mode, which requires the functions <a href="../io/#binread/2"><code class="inline">IO.binread/2</code></a> and <a href="../io/#binwrite/2"><code class="inline">IO.binwrite/2</code></a> to interact with the file. A developer may pass <code class="inline">:utf8</code> as an option when opening the file and then all other functions from <a href="../io/"><code class="inline">IO</code></a> are available, since they work directly with Unicode data.</p> <p><code class="inline">modes_or_function</code> can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling <code class="inline">open(path, [], modes_or_function)</code>. See the documentation for <a href="#open/3"><code class="inline">open/3</code></a> for more information on this function.</p> <p>The allowed modes:</p> <ul> <li>
<p><code class="inline">:binary</code> - opens the file in binary mode, disabling special handling of unicode sequences (default mode).</p> </li> <li>
<p><code class="inline">:read</code> - the file, which must exist, is opened for reading.</p> </li> <li>
<p><code class="inline">:write</code> - the file is opened for writing. It is created if it does not exist.</p> <p>If the file does exists, and if write is not combined with read, the file will be truncated.</p> </li> <li>
<p><code class="inline">:append</code> - the file will be opened for writing, and it will be created if it does not exist. Every write operation to a file opened with append will take place at the end of the file.</p> </li> <li>
<p><code class="inline">:exclusive</code> - the file, when opened for writing, is created if it does not exist. If the file exists, open will return <code class="inline">{:error, :eexist}</code>.</p> </li> <li>
<p><code class="inline">:charlist</code> - when this term is given, read operations on the file will return charlists rather than binaries.</p> </li> <li>
<p><code class="inline">:compressed</code> - makes it possible to read or write gzip compressed files.</p> <p>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with <a href="#stat/1"><code class="inline">stat/1</code></a> will most probably not match the number of bytes that can be read from a compressed file.</p> </li> <li>
<p><code class="inline">:utf8</code> - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8.</p> <p>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</p> </li> <li>
<p><code class="inline">:delayed_write</code>, <code class="inline">:raw</code>, <code class="inline">:ram</code>, <code class="inline">:read_ahead</code>, <code class="inline">:sync</code>, <code class="inline">{:encoding, ...}</code>, <code class="inline">{:read_ahead, pos_integer}</code>, <code class="inline">{:delayed_write, non_neg_integer, non_neg_integer}</code> - for more information about these options see <a href="http://www.erlang.org/doc/man/file.html#open-2" target="_blank"><code class="inline">:file.open/2</code></a>.</p> </li> </ul> <p>This function returns:</p> <ul> <li>
<p><code class="inline">{:ok, io_device}</code> - the file has been opened in the requested mode.</p> <p><code class="inline">io_device</code> is actually the PID of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the <code class="inline">io_device</code> is linked terminates, the file will be closed and the process itself will be terminated.</p> <p>An <code class="inline">io_device</code> returned from this call can be used as an argument to the <a href="../io/"><code class="inline">IO</code></a> module functions.</p> </li> <li>
<p><code class="inline">{:error, reason}</code> - the file could not be opened.</p> </li> </ul> <h4 id="open/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, file} = File.open("foo.tar.gz", [:read, :compressed])
IO.read(file, :line)
File.close(file)</pre>    <h3 class="detail-header function" id="open/3">  <h1 class="signature">open(path, modes, function)</h1>     </h3>
<pre data-language="elixir">open(Path.t(), [mode() | :ram], (io_device() -&gt; res)) ::
  {:ok, res} | {:error, posix()}
when res: var</pre>  <p>Similar to <a href="#open/2"><code class="inline">open/2</code></a> but expects a function as its last argument.</p> <p>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</p> <p>Returns <code class="inline">{:ok, function_result}</code> in case of success, <code class="inline">{:error, reason}</code> otherwise.</p> <p>This function expects the file to be closed with success, which is usually the case unless the <code class="inline">:delayed_write</code> option is given. For this reason, we do not recommend passing <code class="inline">:delayed_write</code> to this function.</p> <h4 id="open/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.open("file.txt", [:read, :write], fn file -&gt;
  IO.read(file, :line)
end)</pre> <p>See <a href="#open/2"><code class="inline">open/2</code></a> for the list of available <code class="inline">modes</code>.</p>     <h3 class="detail-header function" id="open!/2">  <h1 class="signature">open!(path, modes_or_function \\ [])</h1>      </h3>
<pre data-language="elixir">open!(Path.t(), (io_device() -&gt; res)) :: res when res: var</pre>
<pre data-language="elixir">open!(Path.t(), [mode() | :ram]) :: io_device()</pre>  <p>Similar to <a href="#open/2"><code class="inline">open/2</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if the file could not be opened. Returns the IO device otherwise.</p> <p>See <a href="#open/2"><code class="inline">open/2</code></a> for the list of available modes.</p>    <h3 class="detail-header function" id="open!/3">  <h1 class="signature">open!(path, modes, function)</h1>     </h3>
<pre data-language="elixir">open!(Path.t(), [mode() | :ram], (io_device() -&gt; res)) :: res when res: var</pre>  <p>Similar to <a href="#open/3"><code class="inline">open/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if the file could not be opened.</p> <p>If it succeeds opening the file, it returns the <code class="inline">function</code> result on the IO device.</p> <p>See <a href="#open/2"><code class="inline">open/2</code></a> for the list of available <code class="inline">modes</code>.</p>    <h3 class="detail-header function" id="read/1">  <h1 class="signature">read(path)</h1>     </h3>
<pre data-language="elixir">read(Path.t()) :: {:ok, binary()} | {:error, posix()}</pre>  <p>Returns <code class="inline">{:ok, binary}</code>, where <code class="inline">binary</code> is a binary data object that contains the contents of <code class="inline">path</code>, or <code class="inline">{:error, reason}</code> if an error occurs.</p> <p>Typical error reasons:</p> <ul> <li>
<code class="inline">:enoent</code> - the file does not exist </li> <li>
<code class="inline">:eacces</code> - missing permission for reading the file, or for searching one of the parent directories </li> <li>
<code class="inline">:eisdir</code> - the named file is a directory </li> <li>
<code class="inline">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class="inline">:enoent</code> is returned instead </li> <li>
<code class="inline">:enomem</code> - there is not enough memory for the contents of the file </li> </ul> <p>You can use <a href="http://www.erlang.org/doc/man/file.html#format_error-1" target="_blank"><code class="inline">:file.format_error/1</code></a> to get a descriptive string of the error.</p>    <h3 class="detail-header function" id="read!/1">  <h1 class="signature">read!(path)</h1>     </h3>
<pre data-language="elixir">read!(Path.t()) :: binary()</pre>  <p>Returns a binary with the contents of the given filename, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error occurs.</p>    <h3 class="detail-header function" id="read_link/1">  <h1 class="signature">read_link(path)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">read_link(Path.t()) :: {:ok, binary()} | {:error, posix()}</pre>  <p>Reads the symbolic link at <code class="inline">path</code>.</p> <p>If <code class="inline">path</code> exists and is a symlink, returns <code class="inline">{:ok, target}</code>, otherwise returns <code class="inline">{:error, reason}</code>.</p> <p>For more details, see <a href="http://www.erlang.org/doc/man/file.html#read_link-1" target="_blank"><code class="inline">:file.read_link/1</code></a>.</p> <p>Typical error reasons are:</p> <ul> <li>
<code class="inline">:einval</code> - path is not a symbolic link </li> <li>
<code class="inline">:enoent</code> - path does not exist </li> <li>
<code class="inline">:enotsup</code> - symbolic links are not supported on the current platform </li> </ul>    <h3 class="detail-header function" id="read_link!/1">  <h1 class="signature">read_link!(path)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">read_link!(Path.t()) :: binary()</pre>  <p>Same as <a href="#read_link/1"><code class="inline">read_link/1</code></a> but returns the target directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p>     <h3 class="detail-header function" id="regular?/2">  <h1 class="signature">regular?(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">regular?(Path.t(), [regular_option]) :: boolean() when regular_option: :raw</pre>  <p>Returns <code class="inline">true</code> if the path is a regular file.</p> <p>This function follows symbolic links, so if a symbolic link points to a regular file, <code class="inline">true</code> is returned.</p> <h4 id="regular?/2-options" class="section-heading">  Options </h4> <p>The supported options are:</p> <ul> <li>
<code class="inline">:raw</code> - a single atom to bypass the file server and only check for the file locally </li> </ul> <h4 id="regular?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.regular?(__ENV__.file)
#=&gt; true</pre>    <h3 class="detail-header function" id="rename/2">  <h1 class="signature">rename(source, destination)</h1>     </h3>
<pre data-language="elixir">rename(Path.t(), Path.t()) :: :ok | {:error, posix()}</pre>  <p>Renames the <code class="inline">source</code> file to <code class="inline">destination</code> file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the <code class="inline">destination</code> filename, it is not sufficient to simply specify its directory.</p> <p>Returns <code class="inline">:ok</code> in case of success, <code class="inline">{:error, reason}</code> otherwise.</p> <p>Note: The command <code class="inline">mv</code> in Unix systems behaves differently depending on whether <code class="inline">source</code> is a file and the <code class="inline">destination</code> is an existing directory. We have chosen to explicitly disallow this behaviour.</p> <h4 id="rename/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Rename file "a.txt" to "b.txt"
File.rename("a.txt", "b.txt")

# Rename directory "samples" to "tmp"
File.rename("samples", "tmp")</pre>    <h3 class="detail-header function" id="rename!/2">  <h1 class="signature">rename!(source, destination)</h1>  <span class="note">(since 1.9.0)</span>    </h3>
<pre data-language="elixir">rename!(Path.t(), Path.t()) :: :ok</pre>  <p>The same as <a href="#rename/2"><code class="inline">rename/2</code></a> but raises a <a href="../file.renameerror/"><code class="inline">File.RenameError</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>    <h3 class="detail-header function" id="rm/1">  <h1 class="signature">rm(path)</h1>     </h3>
<pre data-language="elixir">rm(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Tries to delete the file <code class="inline">path</code>.</p> <p>Returns <code class="inline">:ok</code> if successful, or <code class="inline">{:error, reason}</code> if an error occurs.</p> <p>Note the file is deleted even if in read-only mode.</p> <p>Typical error reasons are:</p> <ul> <li>
<code class="inline">:enoent</code> - the file does not exist </li> <li>
<code class="inline">:eacces</code> - missing permission for the file or one of its parents </li> <li>
<code class="inline">:eperm</code> - the file is a directory and user is not super-user </li> <li>
<code class="inline">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class="inline">:enoent</code> is returned instead </li> <li>
<code class="inline">:einval</code> - filename had an improper type, such as tuple </li> </ul> <h4 id="rm/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.rm("file.txt")
#=&gt; :ok

File.rm("tmp_dir/")
#=&gt; {:error, :eperm}</pre>    <h3 class="detail-header function" id="rm!/1">  <h1 class="signature">rm!(path)</h1>     </h3>
<pre data-language="elixir">rm!(Path.t()) :: :ok</pre>  <p>Same as <a href="#rm/1"><code class="inline">rm/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>    <h3 class="detail-header function" id="rm_rf/1">  <h1 class="signature">rm_rf(path)</h1>     </h3>
<pre data-language="elixir">rm_rf(Path.t()) :: {:ok, [binary()]} | {:error, posix(), binary()}</pre>  <p>Removes files and directories recursively at the given <code class="inline">path</code>. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</p> <p>Returns <code class="inline">{:ok, files_and_directories}</code> with all files and directories removed in no specific order, <code class="inline">{:error, reason, file}</code> otherwise.</p> <h4 id="rm_rf/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.rm_rf("samples")
#=&gt; {:ok, ["samples", "samples/1.txt"]}

File.rm_rf("unknown")
#=&gt; {:ok, []}</pre>    <h3 class="detail-header function" id="rm_rf!/1">  <h1 class="signature">rm_rf!(path)</h1>     </h3>
<pre data-language="elixir">rm_rf!(Path.t()) :: [binary()]</pre>  <p>Same as <a href="#rm_rf/1"><code class="inline">rm_rf/1</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failures, otherwise the list of files or directories removed.</p>    <h3 class="detail-header function" id="rmdir/1">  <h1 class="signature">rmdir(path)</h1>     </h3>
<pre data-language="elixir">rmdir(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Tries to delete the dir at <code class="inline">path</code>.</p> <p>Returns <code class="inline">:ok</code> if successful, or <code class="inline">{:error, reason}</code> if an error occurs. It returns <code class="inline">{:error, :eexist}</code> if the directory is not empty.</p> <h4 id="rmdir/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.rmdir("tmp_dir")
#=&gt; :ok

File.rmdir("non_empty_dir")
#=&gt; {:error, :eexist}

File.rmdir("file.txt")
#=&gt; {:error, :enotdir}</pre>    <h3 class="detail-header function" id="rmdir!/1">  <h1 class="signature">rmdir!(path)</h1>     </h3>
<pre data-language="elixir">rmdir!(Path.t()) :: :ok | {:error, posix()}</pre>  <p>Same as <a href="#rmdir/1"><code class="inline">rmdir/1</code></a>, but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception in case of failure. Otherwise <code class="inline">:ok</code>.</p>     <h3 class="detail-header function" id="stat/2">  <h1 class="signature">stat(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">stat(Path.t(), stat_options()) :: {:ok, File.Stat.t()} | {:error, posix()}</pre>  <p>Returns information about the <code class="inline">path</code>. If it exists, it returns a <code class="inline">{:ok, info}</code> tuple, where info is a <a href="../file.stat/"><code class="inline">File.Stat</code></a> struct. Returns <code class="inline">{:error, reason}</code> with the same reasons as <a href="#read/1"><code class="inline">read/1</code></a> if a failure occurs.</p> <h4 id="stat/2-options" class="section-heading">  Options </h4> <p>The accepted options are:</p> <ul> <li>
<code class="inline">:time</code> - configures how the file timestamps are returned </li> </ul> <p>The values for <code class="inline">:time</code> can be:</p> <ul> <li>
<code class="inline">:universal</code> - returns a <code class="inline">{date, time}</code> tuple in UTC (default) </li> <li>
<code class="inline">:local</code> - returns a <code class="inline">{date, time}</code> tuple using the same time zone as the machine </li> <li>
<code class="inline">:posix</code> - returns the time as integer seconds since epoch </li> </ul> <p>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the <code class="inline">time: :posix</code> option.</p>     <h3 class="detail-header function" id="stat!/2">  <h1 class="signature">stat!(path, opts \\ [])</h1>     </h3>
<pre data-language="elixir">stat!(Path.t(), stat_options()) :: File.Stat.t()</pre>  <p>Same as <a href="#stat/2"><code class="inline">stat/2</code></a> but returns the <a href="../file.stat/"><code class="inline">File.Stat</code></a> directly, or raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if an error is returned.</p>      <h3 class="detail-header function" id="stream!/3">  <h1 class="signature">stream!(path, modes \\ [], line_or_bytes \\ :line)</h1>     </h3>
<pre data-language="elixir">stream!(Path.t(), stream_mode(), :line | pos_integer()) :: File.Stream.t()</pre>  <p>Returns a <a href="../file.stream/"><code class="inline">File.Stream</code></a> for the given <code class="inline">path</code> with the given <code class="inline">modes</code>.</p> <p>The stream implements both <a href="../enumerable/"><code class="inline">Enumerable</code></a> and <a href="../collectable/"><code class="inline">Collectable</code></a> protocols, which means it can be used both for read and write.</p> <p>The <code class="inline">line_or_bytes</code> argument configures how the file is read when streaming, by <code class="inline">:line</code> (default) or by a given number of bytes.</p> <p>Operating the stream can fail on open for the same reasons as <a href="../file/#open!/2"><code class="inline">File.open!/2</code></a>. Note that the file is automatically opened each time streaming begins. There is no need to pass <code class="inline">:read</code> and <code class="inline">:write</code> modes, as those are automatically set by Elixir.</p> <h4 id="stream!/3-raw-files" class="section-heading">  Raw files </h4> <p>Since Elixir controls when the streamed file is opened, the underlying device cannot be shared and as such it is convenient to open the file in raw mode for performance reasons. Therefore, Elixir <strong>will</strong> open streams in <code class="inline">:raw</code> mode with the <code class="inline">:read_ahead</code> option unless an encoding is specified. This means any data streamed into the file must be converted to <a href="../typespecs/#built-in-types"><code class="inline">iodata/0</code></a> type. If you pass e.g. <code class="inline">[encoding: :utf8]</code> or <code class="inline">[encoding: {:utf16, :little}]</code> in the modes parameter, the underlying stream will use <a href="../io/#write/2"><code class="inline">IO.write/2</code></a> and the <a href="../string.chars/"><code class="inline">String.Chars</code></a> protocol to convert the data. See <a href="../io/#binwrite/2"><code class="inline">IO.binwrite/2</code></a> and <a href="../io/#write/2"><code class="inline">IO.write/2</code></a> .</p> <p>One may also consider passing the <code class="inline">:delayed_write</code> option if the stream is meant to be written to under a tight loop.</p> <h4 id="stream!/3-byte-order-marks" class="section-heading">  Byte order marks </h4> <p>If you pass <code class="inline">:trim_bom</code> in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</p> <p>Note that this function does not try to discover the file encoding basing on BOM.</p> <h4 id="stream!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Read in 2048 byte chunks rather than lines
File.stream!("./test/test.data", [], 2048)
#=&gt; %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],
#=&gt;   path: "./test/test.data", raw: true}</pre> <p>See <a href="../stream/#run/1"><code class="inline">Stream.run/1</code></a> for an example of streaming into a file.</p>     <h3 class="detail-header function" id="touch/2">  <h1 class="signature">touch(path, time \\ System.os_time(:second))</h1>     </h3>
<pre data-language="elixir">touch(Path.t(), erlang_time() | posix_time()) :: :ok | {:error, posix()}</pre>  <p>Updates modification time (mtime) and access time (atime) of the given file.</p> <p>The file is created if it doesn't exist. Requires datetime in UTC (as returned by <code class="inline">:erlang.universaltime()</code>) or an integer representing the POSIX timestamp (as returned by <code class="inline">System.os_time(:second)</code>).</p> <p>In Unix-like systems, changing the modification time may require you to be either <code class="inline">root</code> or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with <code class="inline">{:error, :eperm}</code>.</p> <h4 id="touch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.touch("/tmp/a.txt", {{2018, 1, 30}, {13, 59, 59}})
#=&gt; :ok
File.touch("/fakedir/b.txt", {{2018, 1, 30}, {13, 59, 59}})
{:error, :enoent}

File.touch("/tmp/a.txt", 1544519753)
#=&gt; :ok</pre>     <h3 class="detail-header function" id="touch!/2">  <h1 class="signature">touch!(path, time \\ System.os_time(:second))</h1>     </h3>
<pre data-language="elixir">touch!(Path.t(), erlang_time() | posix_time()) :: :ok</pre>  <p>Same as <a href="#touch/2"><code class="inline">touch/2</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p> <p>The file is created if it doesn't exist. Requires datetime in UTC (as returned by <code class="inline">:erlang.universaltime()</code>) or an integer representing the POSIX timestamp (as returned by <code class="inline">System.os_time(:second)</code>).</p> <h4 id="touch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">File.touch!("/tmp/a.txt", {{2018, 1, 30}, {13, 59, 59}})
#=&gt; :ok
File.touch!("/fakedir/b.txt", {{2018, 1, 30}, {13, 59, 59}})
#=&gt; ** (File.Error) could not touch "/fakedir/b.txt": no such file or directory

File.touch!("/tmp/a.txt", 1544519753)</pre>     <h3 class="detail-header function" id="write/3">  <h1 class="signature">write(path, content, modes \\ [])</h1>     </h3>
<pre data-language="elixir">write(Path.t(), iodata(), [mode()]) :: :ok | {:error, posix()}</pre>  <p>Writes <code class="inline">content</code> to the file <code class="inline">path</code>.</p> <p>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns <code class="inline">:ok</code> if successful, or <code class="inline">{:error, reason}</code> if an error occurs.</p> <p><code class="inline">content</code> must be <code class="inline">iodata</code> (a list of bytes or a binary). Setting the encoding for this function has no effect.</p> <p><strong>Warning:</strong> Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via <a href="../file/#open/2"><code class="inline">File.open/2</code></a> and using the functions in <a href="../io/"><code class="inline">IO</code></a> to write to the file will yield much better performance than calling this function multiple times.</p> <p>Typical error reasons are:</p> <ul> <li>
<code class="inline">:enoent</code> - a component of the file name does not exist </li> <li>
<code class="inline">:enotdir</code> - a component of the file name is not a directory; on some platforms, <code class="inline">:enoent</code> is returned instead </li> <li>
<code class="inline">:enospc</code> - there is no space left on the device </li> <li>
<code class="inline">:eacces</code> - missing permission for writing the file or searching one of the parent directories </li> <li>
<code class="inline">:eisdir</code> - the named file is a directory </li> </ul> <p>Check <a href="../file/#open/2"><code class="inline">File.open/2</code></a> for other available options.</p>     <h3 class="detail-header function" id="write!/3">  <h1 class="signature">write!(path, content, modes \\ [])</h1>     </h3>
<pre data-language="elixir">write!(Path.t(), iodata(), [mode()]) :: :ok</pre>  <p>Same as <a href="#write/3"><code class="inline">write/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>     <h3 class="detail-header function" id="write_stat/3">  <h1 class="signature">write_stat(path, stat, opts \\ [])</h1>     </h3>
<pre data-language="elixir">write_stat(Path.t(), File.Stat.t(), stat_options()) :: :ok | {:error, posix()}</pre>  <p>Writes the given <a href="../file.stat/"><code class="inline">File.Stat</code></a> back to the file system at the given path. Returns <code class="inline">:ok</code> or <code class="inline">{:error, reason}</code>.</p>     <h3 class="detail-header function" id="write_stat!/3">  <h1 class="signature">write_stat!(path, stat, opts \\ [])</h1>     </h3>
<pre data-language="elixir">write_stat!(Path.t(), File.Stat.t(), stat_options()) :: :ok</pre>  <p>Same as <a href="#write_stat/3"><code class="inline">write_stat/3</code></a> but raises a <a href="../file.error/"><code class="inline">File.Error</code></a> exception if it fails. Returns <code class="inline">:ok</code> otherwise.</p>
<div class="_attribution">
  <p class="_attribution-p">
     2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/File.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/File.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
