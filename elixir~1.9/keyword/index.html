
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Keyword - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" A set of functions for working with keywords. ">
  <meta name="keywords" content="keyword, summary, types, key, t, value, functions, delete, keywords, first, drop, keys, equal, left, right, fetch, fetch!, get, default, nil, and, update, fun, update!, lazy, values, has, term, merge, new, pairs, transform, pop, put, replace!, split, take, list, initial, -, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/keyword/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Keyword  </h1>  <p>A set of functions for working with keywords.</p> <p>A keyword list is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</p> <p>For example, the following is a keyword list:</p> <pre data-language="elixir">[{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]</pre> <p>Elixir provides a special and more concise syntax for keyword lists that looks like this:</p> <pre data-language="elixir">[exit_on_close: true, active: :once, packet_size: 1024]</pre> <p>This is also the syntax that Elixir uses to inspect keyword lists:</p> <pre data-language="elixir">iex&gt; [{:active, :once}]
[active: :once]</pre> <p>The two syntaxes are completely equivalent. Like atoms, keywords must be composed of Unicode characters such as letters, numbers, underscore, and <code class="inline">@</code>. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</p> <pre data-language="elixir">iex&gt; ["exit on close": true]
["exit on close": true]</pre> <p>Wrapping a keyword in quotes does not make it a string. Keywords are always atoms. If you use quotes when all characters are a valid part of a keyword without quotes, Elixir will warn.</p> <p>Note that when keyword lists are passed as the last argument to a function, if the short-hand syntax is used then the square brackets around the keyword list can be omitted as well. For example, the following:</p> <pre data-language="elixir">String.split("1-0", "-", trim: true, parts: 2)</pre> <p>is equivalent to:</p> <pre data-language="elixir">String.split("1-0", "-", [trim: true, parts: 2])</pre> <p>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the <a href="../map/"><code class="inline">Map</code></a> module.</p> <p>For example, <a href="../keyword/#get/3"><code class="inline">Keyword.get/3</code></a> will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, <a href="../keyword/#put/3"><code class="inline">Keyword.put/3</code></a> and <a href="../keyword/#delete/3"><code class="inline">Keyword.delete/3</code></a> ensure all duplicated entries for a given key are removed when invoked. Note that operations that require keys to be found in the keyword list (like <a href="../keyword/#get/3"><code class="inline">Keyword.get/3</code></a>) need to traverse the list in order to find keys, so these operations may be slower than their map counterparts.</p> <p>A handful of functions exist to handle duplicated keys, in particular, <a href="../enum/#into/2"><code class="inline">Enum.into/2</code></a> allows creating new keywords without removing duplicated keys, <a href="#get_values/2"><code class="inline">get_values/2</code></a> returns all values for a given key and <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> deletes just one of the existing entries.</p> <p>The functions in <a href="#content"><code class="inline">Keyword</code></a> do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in <a href="../enum/"><code class="inline">Enum</code></a> and <a href="../list/"><code class="inline">List</code></a> can be applied too, especially when ordering is required.</p> <p>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:key/0">key()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/1">t(value)</a> </dt>   <dt class="summary-signature"> <a href="#t:value/0">value()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#delete/2">delete(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the entries in the keyword list for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#delete/3">delete(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Deletes the entries in the keyword list for a <code class="inline">key</code> with <code class="inline">value</code>.</p></dd>   <dt class="summary-signature"> <a href="#delete_first/2">delete_first(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the first entry in the keyword list for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#drop/2">drop(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Drops the given keys from the keyword list.</p></dd>   <dt class="summary-signature"> <a href="#equal?/2">equal?(left, right)</a> </dt> <dd class="summary-synopsis"><p>Checks if two keywords are equal.</p></dd>   <dt class="summary-signature"> <a href="#fetch/2">fetch(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p></dd>   <dt class="summary-signature"> <a href="#fetch!/2">fetch!(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#get/3">get(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_and_update/3">get_and_update(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p></dd>   <dt class="summary-signature"> <a href="#get_and_update!/3">get_and_update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_lazy/3">get_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#get_values/2">get_values(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Gets all values for a specific <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#has_key?/2">has_key?(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p></dd>   <dt class="summary-signature"> <a href="#keys/1">keys(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all keys from the keyword list.</p></dd>   <dt class="summary-signature"> <a href="#keyword?/1">keyword?(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list; otherwise returns <code class="inline">false</code>.</p></dd>   <dt class="summary-signature"> <a href="#merge/2">merge(keywords1, keywords2)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd>   <dt class="summary-signature"> <a href="#merge/3">merge(keywords1, keywords2, fun)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd>   <dt class="summary-signature"> <a href="#new/0">new()</a> </dt> <dd class="summary-synopsis"><p>Returns an empty keyword list, i.e. an empty list.</p></dd>   <dt class="summary-signature"> <a href="#new/1">new(pairs)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable.</p></dd>   <dt class="summary-signature"> <a href="#new/2">new(pairs, transform)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable via the transformation function.</p></dd>   <dt class="summary-signature"> <a href="#pop/3">pop(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p></dd>   <dt class="summary-signature"> <a href="#pop_first/3">pop_first(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p></dd>   <dt class="summary-signature"> <a href="#pop_lazy/3">pop_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p></dd>   <dt class="summary-signature"> <a href="#put/3">put(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>.</p></dd>   <dt class="summary-signature"> <a href="#put_new/3">put_new(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists.</p></dd>   <dt class="summary-signature"> <a href="#put_new_lazy/3">put_new_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p></dd>   <dt class="summary-signature"> <a href="#replace!/3">replace!(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Alters the value stored under <code class="inline">key</code> to <code class="inline">value</code>, but only if the entry <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd>   <dt class="summary-signature"> <a href="#split/2">split(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</p></dd>   <dt class="summary-signature"> <a href="#take/2">take(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given keys and returns them in a new keyword list.</p></dd>   <dt class="summary-signature"> <a href="#to_list/1">to_list(keyword)</a> </dt> <dd class="summary-synopsis"><p>Returns the keyword list itself.</p></dd>   <dt class="summary-signature"> <a href="#update/4">update(keywords, key, initial, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the <code class="inline">key</code> in <code class="inline">keywords</code> with the given function.</p></dd>   <dt class="summary-signature"> <a href="#update!/3">update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the <code class="inline">key</code> with the given function.</p></dd>   <dt class="summary-signature"> <a href="#values/1">values(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all values from the keyword list.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:key/0">  <h1 class="signature">key()</h1>     </h3>
<pre data-language="elixir">key() :: atom()</pre>     <h3 class="detail-header type" id="t:t/0">  <h1 class="signature">t()</h1>     </h3>
<pre data-language="elixir">t() :: [{key(), value()}]</pre>     <h3 class="detail-header type" id="t:t/1">  <h1 class="signature">t(value)</h1>     </h3>
<pre data-language="elixir">t(value) :: [{key(), value}]</pre>     <h3 class="detail-header type" id="t:value/0">  <h1 class="signature">value()</h1>     </h3>
<pre data-language="elixir">value() :: any()</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="delete/2">  <h1 class="signature">delete(keywords, key)</h1>     </h3>
<pre data-language="elixir">delete(t(), key()) :: t()</pre>  <p>Deletes the entries in the keyword list for a specific <code class="inline">key</code>.</p> <p>If the <code class="inline">key</code> does not exist, returns the keyword list unchanged. Use <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> to delete just the first entry in case of duplicated keys.</p> <h4 id="delete/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.delete([a: 1, b: 2], :a)
[b: 2]
iex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a)
[b: 2]
iex&gt; Keyword.delete([b: 2], :a)
[b: 2]</pre>    <h3 class="detail-header function" id="delete/3">  <h1 class="signature">delete(keywords, key, value)</h1>     </h3>
<pre data-language="elixir">delete(t(), key(), value()) :: t()</pre>  <p>Deletes the entries in the keyword list for a <code class="inline">key</code> with <code class="inline">value</code>.</p> <p>If no <code class="inline">key</code> with <code class="inline">value</code> exists, returns the keyword list unchanged.</p> <h4 id="delete/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.delete([a: 1, b: 2], :a, 1)
[b: 2]
iex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a, 3)
[a: 1, b: 2]
iex&gt; Keyword.delete([a: 1], :a, 5)
[a: 1]
iex&gt; Keyword.delete([a: 1], :b, 5)
[a: 1]</pre>    <h3 class="detail-header function" id="delete_first/2">  <h1 class="signature">delete_first(keywords, key)</h1>     </h3>
<pre data-language="elixir">delete_first(t(), key()) :: t()</pre>  <p>Deletes the first entry in the keyword list for a specific <code class="inline">key</code>.</p> <p>If the <code class="inline">key</code> does not exist, returns the keyword list unchanged.</p> <h4 id="delete_first/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.delete_first([a: 1, b: 2, a: 3], :a)
[b: 2, a: 3]
iex&gt; Keyword.delete_first([b: 2], :a)
[b: 2]</pre>    <h3 class="detail-header function" id="drop/2">  <h1 class="signature">drop(keywords, keys)</h1>     </h3>
<pre data-language="elixir">drop(t(), [key()]) :: t()</pre>  <p>Drops the given keys from the keyword list.</p> <p>Duplicated keys are preserved in the new keyword list.</p> <h4 id="drop/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])
[a: 1, c: 3]
iex&gt; Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])
[a: 1, c: 3, a: 5]</pre>    <h3 class="detail-header function" id="equal?/2">  <h1 class="signature">equal?(left, right)</h1>     </h3>
<pre data-language="elixir">equal?(t(), t()) :: boolean()</pre>  <p>Checks if two keywords are equal.</p> <p>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</p> <h4 id="equal?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])
true
iex&gt; Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])
false
iex&gt; Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])
true</pre>    <h3 class="detail-header function" id="fetch/2">  <h1 class="signature">fetch(keywords, key)</h1>     </h3>
<pre data-language="elixir">fetch(t(), key()) :: {:ok, value()} | :error</pre>  <p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p> <p>If the <code class="inline">key</code> does not exist, returns <code class="inline">:error</code>.</p> <h4 id="fetch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.fetch([a: 1], :a)
{:ok, 1}
iex&gt; Keyword.fetch([a: 1], :b)
:error</pre>    <h3 class="detail-header function" id="fetch!/2">  <h1 class="signature">fetch!(keywords, key)</h1>     </h3>
<pre data-language="elixir">fetch!(t(), key()) :: value()</pre>  <p>Fetches the value for specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, a <a href="../keyerror/"><code class="inline">KeyError</code></a> is raised.</p> <h4 id="fetch!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.fetch!([a: 1], :a)
1
iex&gt; Keyword.fetch!([a: 1], :b)
** (KeyError) key :b not found in: [a: 1]</pre>     <h3 class="detail-header function" id="get/3">  <h1 class="signature">get(keywords, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">get(t(), key(), value()) :: value()</pre>  <p>Gets the value for a specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, return the default value (<code class="inline">nil</code> if no default value).</p> <p>If duplicated entries exist, the first one is returned. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p> <h4 id="get/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get([], :a)
nil
iex&gt; Keyword.get([a: 1], :a)
1
iex&gt; Keyword.get([a: 1], :b)
nil
iex&gt; Keyword.get([a: 1], :b, 3)
3</pre> <p>With duplicated keys:</p> <pre data-language="elixir">iex&gt; Keyword.get([a: 1, a: 2], :a, 3)
1
iex&gt; Keyword.get([a: 1, a: 2], :b, 3)
3</pre>    <h3 class="detail-header function" id="get_and_update/3">  <h1 class="signature">get_and_update(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">get_and_update(t(), key(), (value() -&gt; {get, value()} | :pop)) ::
  {get, t()}
when get: term()</pre>  <p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p> <p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return a two-element tuple: the "get" value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>. The <code class="inline">fun</code> may also return <code class="inline">:pop</code>, implying the current value shall be removed from the keyword list and returned.</p> <p>The returned value is a tuple with the "get" value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p> <h4 id="get_and_update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{nil, [b: "new value!", a: 1]}

iex&gt; Keyword.get_and_update([a: 1], :a, fn _ -&gt; :pop end)
{1, []}

iex&gt; Keyword.get_and_update([a: 1], :b, fn _ -&gt; :pop end)
{nil, [a: 1]}</pre>    <h3 class="detail-header function" id="get_and_update!/3">  <h1 class="signature">get_and_update!(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">get_and_update!(t(), key(), (value() -&gt; {get, value()})) :: {get, t()}
when get: term()</pre>  <p>Gets the value from <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p> <p>This <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> and must return a two-element tuple: the "get" value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>.</p> <p>The returned value is a tuple with the "get" value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p> <h4 id="get_and_update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update!([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update!([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
** (KeyError) key :b not found in: [a: 1]

iex&gt; Keyword.get_and_update!([a: 1], :a, fn _ -&gt;
...&gt;   :pop
...&gt; end)
{1, []}</pre>    <h3 class="detail-header function" id="get_lazy/3">  <h1 class="signature">get_lazy(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">get_lazy(t(), key(), (() -&gt; value())) :: value()</pre>  <p>Gets the value for a specific <code class="inline">key</code>.</p> <p>If <code class="inline">key</code> does not exist, lazily evaluates <code class="inline">fun</code> and returns its result.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <p>If duplicated entries exist, the first one is returned. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p> <h4 id="get_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.get_lazy(keyword, :a, fun)
1
iex&gt; Keyword.get_lazy(keyword, :b, fun)
13</pre>    <h3 class="detail-header function" id="get_values/2">  <h1 class="signature">get_values(keywords, key)</h1>     </h3>
<pre data-language="elixir">get_values(t(), key()) :: [value()]</pre>  <p>Gets all values for a specific <code class="inline">key</code>.</p> <h4 id="get_values/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.get_values([], :a)
[]
iex&gt; Keyword.get_values([a: 1], :a)
[1]
iex&gt; Keyword.get_values([a: 1, a: 2], :a)
[1, 2]</pre>    <h3 class="detail-header function" id="has_key?/2">  <h1 class="signature">has_key?(keywords, key)</h1>     </h3>
<pre data-language="elixir">has_key?(t(), key()) :: boolean()</pre>  <p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p> <h4 id="has_key?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.has_key?([a: 1], :a)
true
iex&gt; Keyword.has_key?([a: 1], :b)
false</pre>    <h3 class="detail-header function" id="keys/1">  <h1 class="signature">keys(keywords)</h1>     </h3>
<pre data-language="elixir">keys(t()) :: [key()]</pre>  <p>Returns all keys from the keyword list.</p> <p>Duplicated keys appear duplicated in the final list of keys.</p> <h4 id="keys/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.keys(a: 1, b: 2)
[:a, :b]
iex&gt; Keyword.keys(a: 1, b: 2, a: 3)
[:a, :b, :a]</pre>    <h3 class="detail-header function" id="keyword?/1">  <h1 class="signature">keyword?(term)</h1>     </h3>
<pre data-language="elixir">keyword?(term()) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list; otherwise returns <code class="inline">false</code>.</p> <h4 id="keyword?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.keyword?([])
true
iex&gt; Keyword.keyword?(a: 1)
true
iex&gt; Keyword.keyword?([{Foo, 1}])
true
iex&gt; Keyword.keyword?([{}])
false
iex&gt; Keyword.keyword?([:key])
false
iex&gt; Keyword.keyword?(%{})
false</pre>    <h3 class="detail-header function" id="merge/2">  <h1 class="signature">merge(keywords1, keywords2)</h1>     </h3>
<pre data-language="elixir">merge(t(), t()) :: t()</pre>  <p>Merges two keyword lists into one.</p> <p>All keys, including duplicated keys, given in <code class="inline">keywords2</code> will be added to <code class="inline">keywords1</code>, overriding any existing one.</p> <p>There are no guarantees about the order of keys in the returned keyword.</p> <h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4])
[b: 2, a: 3, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])
[b: 2, a: 3, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1], [2, 3])
** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]</pre>    <h3 class="detail-header function" id="merge/3">  <h1 class="signature">merge(keywords1, keywords2, fun)</h1>     </h3>
<pre data-language="elixir">merge(t(), t(), (key(), value(), value() -&gt; value())) :: t()</pre>  <p>Merges two keyword lists into one.</p> <p>All keys, including duplicated keys, given in <code class="inline">keywords2</code> will be added to <code class="inline">keywords1</code>. The given function will be invoked to solve conflicts.</p> <p>If <code class="inline">keywords2</code> has duplicate keys, the given function will be invoked for each matching pair in <code class="inline">keywords1</code>.</p> <p>There are no guarantees about the order of keys in the returned keyword.</p> <h4 id="merge/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 8]

iex&gt; Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]</pre>    <h3 class="detail-header function" id="new/0">  <h1 class="signature">new()</h1>     </h3>
<pre data-language="elixir">new() :: []</pre>  <p>Returns an empty keyword list, i.e. an empty list.</p> <h4 id="new/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new()
[]</pre>    <h3 class="detail-header function" id="new/1">  <h1 class="signature">new(pairs)</h1>     </h3>
<pre data-language="elixir">new(Enum.t()) :: t()</pre>  <p>Creates a keyword list from an enumerable.</p> <p>Duplicated entries are removed, the latest one prevails. Unlike <code class="inline">Enum.into(enumerable, [])</code>, <code class="inline">Keyword.new(enumerable)</code> guarantees the keys are unique.</p> <h4 id="new/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new([{:b, 1}, {:a, 2}])
[b: 1, a: 2]

iex&gt; Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])
[a: 3]</pre>    <h3 class="detail-header function" id="new/2">  <h1 class="signature">new(pairs, transform)</h1>     </h3>
<pre data-language="elixir">new(Enum.t(), (term() -&gt; {key(), value()})) :: t()</pre>  <p>Creates a keyword list from an enumerable via the transformation function.</p> <p>Duplicated entries are removed, the latest one prevails. Unlike <code class="inline">Enum.into(enumerable, [], fun)</code>, <code class="inline">Keyword.new(enumerable, fun)</code> guarantees the keys are unique.</p> <h4 id="new/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.new([:a, :b], fn x -&gt; {x, x} end)
[a: :a, b: :b]</pre>     <h3 class="detail-header function" id="pop/3">  <h1 class="signature">pop(keywords, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">pop(t(), key(), value()) :: {value(), t()}</pre>  <p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p> <p>It returns a tuple where the first element is the first value for <code class="inline">key</code> and the second element is a keyword list with all entries associated with <code class="inline">key</code> removed. If the <code class="inline">key</code> is not present in the keyword list, <code class="inline">{default, keyword_list}</code> is returned.</p> <p>If you don't want to remove all the entries associated with <code class="inline">key</code> use <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> instead, that function will remove only the first entry.</p> <h4 id="pop/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop([a: 1], :a)
{1, []}
iex&gt; Keyword.pop([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop([a: 1, a: 2], :a)
{1, []}</pre>     <h3 class="detail-header function" id="pop_first/3">  <h1 class="signature">pop_first(keywords, key, default \\ nil)</h1>     </h3>
<pre data-language="elixir">pop_first(t(), key(), value()) :: {value(), t()}</pre>  <p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p> <p>Duplicated keys are not removed.</p> <h4 id="pop_first/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.pop_first([a: 1], :a)
{1, []}
iex&gt; Keyword.pop_first([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop_first([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop_first([a: 1, a: 2], :a)
{1, [a: 2]}</pre>    <h3 class="detail-header function" id="pop_lazy/3">  <h1 class="signature">pop_lazy(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">pop_lazy(t(), key(), (() -&gt; value())) :: {value(), t()}</pre>  <p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p> <p>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</p> <p>All duplicated keys are removed. See <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> for removing only the first entry.</p> <h4 id="pop_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.pop_lazy(keyword, :a, fun)
{1, []}
iex&gt; Keyword.pop_lazy(keyword, :b, fun)
{13, [a: 1]}</pre>    <h3 class="detail-header function" id="put/3">  <h1 class="signature">put(keywords, key, value)</h1>     </h3>
<pre data-language="elixir">put(t(), key(), value()) :: t()</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>.</p> <p>If a previous value is already stored, all entries are removed and the value is overridden.</p> <h4 id="put/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.put([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put([a: 1, b: 2], :a, 3)
[a: 3, b: 2]
iex&gt; Keyword.put([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]</pre>    <h3 class="detail-header function" id="put_new/3">  <h1 class="signature">put_new(keywords, key, value)</h1>     </h3>
<pre data-language="elixir">put_new(t(), key(), value()) :: t()</pre>  <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code> unless the entry <code class="inline">key</code> already exists.</p> <h4 id="put_new/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.put_new([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put_new([a: 1, b: 2], :a, 3)
[a: 1, b: 2]</pre>    <h3 class="detail-header function" id="put_new_lazy/3">  <h1 class="signature">put_new_lazy(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">put_new_lazy(t(), key(), (() -&gt; value())) :: t()</pre>  <p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p> <p>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</p> <h4 id="put_new_lazy/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   3
...&gt; end
iex&gt; Keyword.put_new_lazy(keyword, :a, fun)
[a: 1]
iex&gt; Keyword.put_new_lazy(keyword, :b, fun)
[b: 3, a: 1]</pre>    <h3 class="detail-header function" id="replace!/3">  <h1 class="signature">replace!(keywords, key, value)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">replace!(t(), key(), value()) :: t()</pre>  <p>Alters the value stored under <code class="inline">key</code> to <code class="inline">value</code>, but only if the entry <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p> <p>If <code class="inline">key</code> is not present in <code class="inline">keywords</code>, a <a href="../keyerror/"><code class="inline">KeyError</code></a> exception is raised.</p> <h4 id="replace!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.replace!([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]

iex&gt; Keyword.replace!([a: 1], :b, 2)
** (KeyError) key :b not found in: [a: 1]</pre>    <h3 class="detail-header function" id="split/2">  <h1 class="signature">split(keywords, keys)</h1>     </h3>
<pre data-language="elixir">split(t(), [key()]) :: {t(), t()}</pre>  <p>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</p> <p>Returns a tuple with the new list and the old list with removed keys.</p> <p>Keys for which there are no entries in the keyword list are ignored.</p> <p>Entries with duplicated keys end up in the same keyword list.</p> <h4 id="split/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])
{[a: 1, c: 3], [b: 2]}
iex&gt; Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])
{[a: 1, c: 3, a: 4], [b: 2]}</pre>    <h3 class="detail-header function" id="take/2">  <h1 class="signature">take(keywords, keys)</h1>     </h3>
<pre data-language="elixir">take(t(), [key()]) :: t()</pre>  <p>Takes all entries corresponding to the given keys and returns them in a new keyword list.</p> <p>Duplicated keys are preserved in the new keyword list.</p> <h4 id="take/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])
[a: 1, c: 3]
iex&gt; Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])
[a: 1, c: 3, a: 5]</pre>    <h3 class="detail-header function" id="to_list/1">  <h1 class="signature">to_list(keyword)</h1>     </h3>
<pre data-language="elixir">to_list(t()) :: t()</pre>  <p>Returns the keyword list itself.</p> <h4 id="to_list/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.to_list(a: 1)
[a: 1]</pre>    <h3 class="detail-header function" id="update/4">  <h1 class="signature">update(keywords, key, initial, fun)</h1>     </h3>
<pre data-language="elixir">update(t(), key(), value(), (value() -&gt; value())) :: t()</pre>  <p>Updates the <code class="inline">key</code> in <code class="inline">keywords</code> with the given function.</p> <p>If the <code class="inline">key</code> does not exist, inserts the given <code class="inline">initial</code> value.</p> <p>If there are duplicated keys, they are all removed and only the first one is updated.</p> <h4 id="update/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.update([a: 1], :a, 13, &amp;(&amp;1 * 2))
[a: 2]
iex&gt; Keyword.update([a: 1, a: 2], :a, 13, &amp;(&amp;1 * 2))
[a: 2]
iex&gt; Keyword.update([a: 1], :b, 11, &amp;(&amp;1 * 2))
[a: 1, b: 11]</pre>    <h3 class="detail-header function" id="update!/3">  <h1 class="signature">update!(keywords, key, fun)</h1>     </h3>
<pre data-language="elixir">update!(t(), key(), (value() -&gt; value())) :: t()</pre>  <p>Updates the <code class="inline">key</code> with the given function.</p> <p>If the <code class="inline">key</code> does not exist, raises <a href="../keyerror/"><code class="inline">KeyError</code></a>.</p> <p>If there are duplicated keys, they are all removed and only the first one is updated.</p> <h4 id="update!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.update!([a: 1], :a, &amp;(&amp;1 * 2))
[a: 2]
iex&gt; Keyword.update!([a: 1, a: 2], :a, &amp;(&amp;1 * 2))
[a: 2]

iex&gt; Keyword.update!([a: 1], :b, &amp;(&amp;1 * 2))
** (KeyError) key :b not found in: [a: 1]</pre>    <h3 class="detail-header function" id="values/1">  <h1 class="signature">values(keywords)</h1>     </h3>
<pre data-language="elixir">values(t()) :: [value()]</pre>  <p>Returns all values from the keyword list.</p> <p>Values from duplicated keys will be kept in the final list of values.</p> <h4 id="values/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Keyword.values(a: 1, b: 2)
[1, 2]
iex&gt; Keyword.values(a: 1, b: 2, a: 3)
[1, 2, 3]</pre>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Keyword.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Keyword.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
