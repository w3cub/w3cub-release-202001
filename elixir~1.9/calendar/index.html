
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Calendar - Elixir 1.9 - W3cubDocs</title>
  
  <meta name="description" content=" This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir. ">
  <meta name="keywords" content="calendar, summary, types, date, datetime, day, fraction, week, era, hour, iso, days, microsecond, minute, month, naive, second, std, offset, time, zone, database, utc, year, abbr, functions, compatible, calendars, get, put, truncate, tuple, atom, callbacks, string, rollover, relative, midnight, leap, months, from, quarter, valid, -, elixir, elixir~1.9">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.9/calendar/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/elixir~1.9.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.9/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.9</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _elixir">
				
				
<h1>  Calendar <small>behaviour</small>  </h1>  <p>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</p> <p>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</p> <p>For the actual date, time and datetime structures, see <a href="../date/"><code class="inline">Date</code></a>, <a href="../time/"><code class="inline">Time</code></a>, <a href="../naivedatetime/"><code class="inline">NaiveDateTime</code></a> and <a href="../datetime/"><code class="inline">DateTime</code></a>.</p> <p>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of <code class="inline">1..12</code> for months) because different calendars may have a different number of days per month, months per year and so on.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:calendar/0">calendar()</a> </dt> <dd class="summary-synopsis"><p>A calendar implementation</p></dd>   <dt class="summary-signature"> <a href="#t:date/0">date()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the date fields</p></dd>   <dt class="summary-signature"> <a href="#t:datetime/0">datetime()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the datetime fields</p></dd>   <dt class="summary-signature"> <a href="#t:day/0">day()</a> </dt>   <dt class="summary-signature"> <a href="#t:day_fraction/0">day_fraction()</a> </dt> <dd class="summary-synopsis"><p>The internal time format is used when converting between calendars.</p></dd>   <dt class="summary-signature"> <a href="#t:day_of_week/0">day_of_week()</a> </dt>   <dt class="summary-signature"> <a href="#t:era/0">era()</a> </dt>   <dt class="summary-signature"> <a href="#t:hour/0">hour()</a> </dt>   <dt class="summary-signature"> <a href="#t:iso_days/0">iso_days()</a> </dt> <dd class="summary-synopsis"><p>The internal date format that is used when converting between calendars.</p></dd>   <dt class="summary-signature"> <a href="#t:microsecond/0">microsecond()</a> </dt> <dd class="summary-synopsis"><p>Microseconds with stored precision.</p></dd>   <dt class="summary-signature"> <a href="#t:minute/0">minute()</a> </dt>   <dt class="summary-signature"> <a href="#t:month/0">month()</a> </dt>   <dt class="summary-signature"> <a href="#t:naive_datetime/0">naive_datetime()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the naive_datetime fields</p></dd>   <dt class="summary-signature"> <a href="#t:second/0">second()</a> </dt>   <dt class="summary-signature"> <a href="#t:std_offset/0">std_offset()</a> </dt> <dd class="summary-synopsis"><p>The time zone standard offset in seconds (not zero in summer times)</p></dd>   <dt class="summary-signature"> <a href="#t:time/0">time()</a> </dt> <dd class="summary-synopsis"><p>Any map/struct that contains the time fields</p></dd>   <dt class="summary-signature"> <a href="#t:time_zone/0">time_zone()</a> </dt> <dd class="summary-synopsis"><p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p></dd>   <dt class="summary-signature"> <a href="#t:time_zone_database/0">time_zone_database()</a> </dt> <dd class="summary-synopsis"><p>Specifies the time zone database for calendar operations.</p></dd>   <dt class="summary-signature"> <a href="#t:utc_offset/0">utc_offset()</a> </dt> <dd class="summary-synopsis"><p>The time zone UTC offset in seconds</p></dd>   <dt class="summary-signature"> <a href="#t:week/0">week()</a> </dt>   <dt class="summary-signature"> <a href="#t:year/0">year()</a> </dt>   <dt class="summary-signature"> <a href="#t:zone_abbr/0">zone_abbr()</a> </dt> <dd class="summary-synopsis"><p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p></dd>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#compatible_calendars?/2">compatible_calendars?(calendar, calendar)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise.</p></dd>   <dt class="summary-signature"> <a href="#get_time_zone_database/0">get_time_zone_database()</a> </dt> <dd class="summary-synopsis"><p>Gets the current time zone database.</p></dd>   <dt class="summary-signature"> <a href="#put_time_zone_database/1">put_time_zone_database(database)</a> </dt> <dd class="summary-synopsis"><p>Sets the current time zone database.</p></dd>   <dt class="summary-signature"> <a href="#truncate/2">truncate(microsecond_tuple, atom)</a> </dt> <dd class="summary-synopsis"><p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p></dd>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:date_to_string/3">date_to_string(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Converts the date into a string according to the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:datetime_to_string/11">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</a> </dt> <dd class="summary-synopsis"><p>Converts the datetime (with time zone) into a string according to the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:day_of_era/3">day_of_era(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day and era from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd>   <dt class="summary-signature"> <a href="#c:day_of_week/3">day_of_week(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd>   <dt class="summary-signature"> <a href="#c:day_of_year/3">day_of_year(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd>   <dt class="summary-signature"> <a href="#c:day_rollover_relative_to_midnight_utc/0">day_rollover_relative_to_midnight_utc()</a> </dt> <dd class="summary-synopsis"><p>Define the rollover moment for the given calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:days_in_month/2">days_in_month(year, month)</a> </dt> <dd class="summary-synopsis"><p>Returns how many days there are in the given year-month.</p></dd>   <dt class="summary-signature"> <a href="#c:leap_year?/1">leap_year?(year)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given year is a leap year.</p></dd>   <dt class="summary-signature"> <a href="#c:months_in_year/1">months_in_year(year)</a> </dt> <dd class="summary-synopsis"><p>Returns how many months there are in the given year.</p></dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_from_iso_days/1">naive_datetime_from_iso_days(iso_days)</a> </dt> <dd class="summary-synopsis"><p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendar's datetime format.</p></dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_to_iso_days/7">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the given datetime (without time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format.</p></dd>   <dt class="summary-signature"> <a href="#c:naive_datetime_to_string/7">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the datetime (without time zone) into a string according to the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:quarter_of_year/3">quarter_of_year(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Calculates the quarter of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p></dd>   <dt class="summary-signature"> <a href="#c:time_from_day_fraction/1">time_from_day_fraction(day_fraction)</a> </dt> <dd class="summary-synopsis"><p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendar's time format.</p></dd>   <dt class="summary-signature"> <a href="#c:time_to_day_fraction/4">time_to_day_fraction(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format.</p></dd>   <dt class="summary-signature"> <a href="#c:time_to_string/4">time_to_string(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Converts the time into a string according to the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:valid_date?/3">valid_date?(year, month, day)</a> </dt> <dd class="summary-synopsis"><p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:valid_time?/4">valid_time?(hour, minute, second, microsecond)</a> </dt> <dd class="summary-synopsis"><p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar.</p></dd>   <dt class="summary-signature"> <a href="#c:year_of_era/1">year_of_era(year)</a> </dt> <dd class="summary-synopsis"><p>Calculates the year and era from the given <code class="inline">year</code>.</p></dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:calendar/0">  <h1 class="signature">calendar()</h1>     </h3>
<pre data-language="elixir">calendar() :: module()</pre>  <p>A calendar implementation</p>    <h3 class="detail-header type" id="t:date/0">  <h1 class="signature">date()</h1>     </h3>
<pre data-language="elixir">date() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day()
}</pre>  <p>Any map/struct that contains the date fields</p>    <h3 class="detail-header type" id="t:datetime/0">  <h1 class="signature">datetime()</h1>     </h3>
<pre data-language="elixir">datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond(),
  :time_zone =&gt; time_zone(),
  :zone_abbr =&gt; zone_abbr(),
  :utc_offset =&gt; utc_offset(),
  :std_offset =&gt; std_offset()
}</pre>  <p>Any map/struct that contains the datetime fields</p>    <h3 class="detail-header type" id="t:day/0">  <h1 class="signature">day()</h1>     </h3>
<pre data-language="elixir">day() :: pos_integer()</pre>     <h3 class="detail-header type" id="t:day_fraction/0">  <h1 class="signature">day_fraction()</h1>     </h3>
<pre data-language="elixir">day_fraction() ::
  {parts_in_day :: non_neg_integer(), parts_per_day :: pos_integer()}</pre>  <p>The internal time format is used when converting between calendars.</p> <p>It represents time as a fraction of a day (starting from midnight). <code class="inline">parts_in_day</code> specifies how much of the day is already passed, while <code class="inline">parts_per_day</code> signifies how many parts there fit in a day.</p>    <h3 class="detail-header type" id="t:day_of_week/0">  <h1 class="signature">day_of_week()</h1>     </h3>
<pre data-language="elixir">day_of_week() :: non_neg_integer()</pre>     <h3 class="detail-header type" id="t:era/0">  <h1 class="signature">era()</h1>     </h3>
<pre data-language="elixir">era() :: non_neg_integer()</pre>     <h3 class="detail-header type" id="t:hour/0">  <h1 class="signature">hour()</h1>     </h3>
<pre data-language="elixir">hour() :: non_neg_integer()</pre>     <h3 class="detail-header type" id="t:iso_days/0">  <h1 class="signature">iso_days()</h1>     </h3>
<pre data-language="elixir">iso_days() :: {days :: integer(), day_fraction()}</pre>  <p>The internal date format that is used when converting between calendars.</p> <p>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</p>    <h3 class="detail-header type" id="t:microsecond/0">  <h1 class="signature">microsecond()</h1>     </h3>
<pre data-language="elixir">microsecond() :: {0..999_999, 0..6}</pre>  <p>Microseconds with stored precision.</p> <p>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</p>    <h3 class="detail-header type" id="t:minute/0">  <h1 class="signature">minute()</h1>     </h3>
<pre data-language="elixir">minute() :: non_neg_integer()</pre>     <h3 class="detail-header type" id="t:month/0">  <h1 class="signature">month()</h1>     </h3>
<pre data-language="elixir">month() :: pos_integer()</pre>     <h3 class="detail-header type" id="t:naive_datetime/0">  <h1 class="signature">naive_datetime()</h1>     </h3>
<pre data-language="elixir">naive_datetime() :: %{
  optional(any()) =&gt; any(),
  :calendar =&gt; calendar(),
  :year =&gt; year(),
  :month =&gt; month(),
  :day =&gt; day(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre>  <p>Any map/struct that contains the naive_datetime fields</p>    <h3 class="detail-header type" id="t:second/0">  <h1 class="signature">second()</h1>     </h3>
<pre data-language="elixir">second() :: non_neg_integer()</pre>     <h3 class="detail-header type" id="t:std_offset/0">  <h1 class="signature">std_offset()</h1>     </h3>
<pre data-language="elixir">std_offset() :: integer()</pre>  <p>The time zone standard offset in seconds (not zero in summer times)</p>    <h3 class="detail-header type" id="t:time/0">  <h1 class="signature">time()</h1>     </h3>
<pre data-language="elixir">time() :: %{
  optional(any()) =&gt; any(),
  :hour =&gt; hour(),
  :minute =&gt; minute(),
  :second =&gt; second(),
  :microsecond =&gt; microsecond()
}</pre>  <p>Any map/struct that contains the time fields</p>    <h3 class="detail-header type" id="t:time_zone/0">  <h1 class="signature">time_zone()</h1>     </h3>
<pre data-language="elixir">time_zone() :: String.t()</pre>  <p>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</p>    <h3 class="detail-header type" id="t:time_zone_database/0">  <h1 class="signature">time_zone_database()</h1>     </h3>
<pre data-language="elixir">time_zone_database() :: module()</pre>  <p>Specifies the time zone database for calendar operations.</p> <p>Many functions in the <a href="../datetime/"><code class="inline">DateTime</code></a> module require a time zone database. By default, it uses the default time zone database returned by <a href="../calendar/#get_time_zone_database/0"><code class="inline">Calendar.get_time_zone_database/0</code></a>, which defaults to <a href="../calendar.utconlytimezonedatabase/"><code class="inline">Calendar.UTCOnlyTimeZoneDatabase</code></a> which only handles "Etc/UTC" datetimes and returns <code class="inline">{:error, :utc_only_time_zone_database}</code> for any other time zone.</p> <p>Other time zone databases (including ones provided by packages) can be configure as default either via configuration:</p> <pre data-language="elixir">config :elixir, :time_zone_database, CustomTimeZoneDatabase</pre> <p>or by calling <a href="../calendar/#put_time_zone_database/1"><code class="inline">Calendar.put_time_zone_database/1</code></a>.</p> <p>See <a href="../calendar.timezonedatabase/"><code class="inline">Calendar.TimeZoneDatabase</code></a> for more information on custom time zone databases.</p>    <h3 class="detail-header type" id="t:utc_offset/0">  <h1 class="signature">utc_offset()</h1>     </h3>
<pre data-language="elixir">utc_offset() :: integer()</pre>  <p>The time zone UTC offset in seconds</p>    <h3 class="detail-header type" id="t:week/0">  <h1 class="signature">week()</h1>     </h3>
<pre data-language="elixir">week() :: pos_integer()</pre>     <h3 class="detail-header type" id="t:year/0">  <h1 class="signature">year()</h1>     </h3>
<pre data-language="elixir">year() :: integer()</pre>     <h3 class="detail-header type" id="t:zone_abbr/0">  <h1 class="signature">zone_abbr()</h1>     </h3>
<pre data-language="elixir">zone_abbr() :: String.t()</pre>  <p>The time zone abbreviation (e.g. CET or CEST or BST etc.)</p>      <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="compatible_calendars?/2">  <h1 class="signature">compatible_calendars?(calendar, calendar)</h1>  <span class="note">(since 1.5.0)</span>    </h3>
<pre data-language="elixir">compatible_calendars?(Calendar.calendar(), Calendar.calendar()) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if two calendars have the same moment of starting a new day, <code class="inline">false</code> otherwise.</p> <p>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</p>    <h3 class="detail-header function" id="get_time_zone_database/0">  <h1 class="signature">get_time_zone_database()</h1>  <span class="note">(since 1.8.0)</span>    </h3>
<pre data-language="elixir">get_time_zone_database() :: time_zone_database()</pre>  <p>Gets the current time zone database.</p>    <h3 class="detail-header function" id="put_time_zone_database/1">  <h1 class="signature">put_time_zone_database(database)</h1>  <span class="note">(since 1.8.0)</span>    </h3>
<pre data-language="elixir">put_time_zone_database(time_zone_database()) :: :ok</pre>  <p>Sets the current time zone database.</p>    <h3 class="detail-header function" id="truncate/2">  <h1 class="signature">truncate(microsecond_tuple, atom)</h1>  <span class="note">(since 1.6.0)</span>    </h3>
<pre data-language="elixir">truncate(Calendar.microsecond(), :microsecond | :millisecond | :second) ::
  Calendar.microsecond()</pre>  <p>Returns a microsecond tuple truncated to a given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p>      <h1 class="section-heading" id="callbacks">  Callbacks </h1>   <h3 class="detail-header callback" id="c:date_to_string/3">  <h1 class="signature">date_to_string(year, month, day)</h1>     </h3>
<pre data-language="elixir">date_to_string(year(), month(), day()) :: String.t()</pre>  <p>Converts the date into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:datetime_to_string/11">  <h1 class="signature">datetime_to_string(year, month, day, hour, minute, second, microsecond, time_zone, zone_abbr, utc_offset, std_offset)</h1>     </h3>
<pre data-language="elixir">datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond(),
  time_zone(),
  zone_abbr(),
  utc_offset(),
  std_offset()
) :: String.t()</pre>  <p>Converts the datetime (with time zone) into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:day_of_era/3">  <h1 class="signature">day_of_era(year, month, day)</h1>     </h3>
<pre data-language="elixir">day_of_era(year(), month(), day()) :: {non_neg_integer(), era()}</pre>  <p>Calculates the day and era from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>    <h3 class="detail-header callback" id="c:day_of_week/3">  <h1 class="signature">day_of_week(year, month, day)</h1>     </h3>
<pre data-language="elixir">day_of_week(year(), month(), day()) :: day_of_week()</pre>  <p>Calculates the day of the week from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>    <h3 class="detail-header callback" id="c:day_of_year/3">  <h1 class="signature">day_of_year(year, month, day)</h1>     </h3>
<pre data-language="elixir">day_of_year(year(), month(), day()) :: non_neg_integer()</pre>  <p>Calculates the day of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>    <h3 class="detail-header callback" id="c:day_rollover_relative_to_midnight_utc/0">  <h1 class="signature">day_rollover_relative_to_midnight_utc()</h1>     </h3>
<pre data-language="elixir">day_rollover_relative_to_midnight_utc() :: day_fraction()</pre>  <p>Define the rollover moment for the given calendar.</p> <p>This is the moment, in your calendar, when the current day ends and the next day starts.</p> <p>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</p> <p>This day fraction should be in its most simplified form possible, to make comparisons fast.</p> <h4 id="c:day_rollover_relative_to_midnight_utc/0-examples" class="section-heading">  Examples </h4> <ul> <li>If, in your Calendar, a new day starts at midnight, return {0, 1}. </li> <li>If, in your Calendar, a new day starts at sunrise, return {1, 4}. </li> <li>If, in your Calendar, a new day starts at noon, return {1, 2}. </li> <li>If, in your Calendar, a new day starts at sunset, return {3, 4}. </li> </ul>    <h3 class="detail-header callback" id="c:days_in_month/2">  <h1 class="signature">days_in_month(year, month)</h1>     </h3>
<pre data-language="elixir">days_in_month(year(), month()) :: day()</pre>  <p>Returns how many days there are in the given year-month.</p>    <h3 class="detail-header callback" id="c:leap_year?/1">  <h1 class="signature">leap_year?(year)</h1>     </h3>
<pre data-language="elixir">leap_year?(year()) :: boolean()</pre>  <p>Returns <code class="inline">true</code> if the given year is a leap year.</p> <p>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return <code class="inline">false</code> if it does not support the concept of leap years.</p>    <h3 class="detail-header callback" id="c:months_in_year/1">  <h1 class="signature">months_in_year(year)</h1>     </h3>
<pre data-language="elixir">months_in_year(year()) :: month()</pre>  <p>Returns how many months there are in the given year.</p>    <h3 class="detail-header callback" id="c:naive_datetime_from_iso_days/1">  <h1 class="signature">naive_datetime_from_iso_days(iso_days)</h1>     </h3>
<pre data-language="elixir">naive_datetime_from_iso_days(iso_days()) ::
  {year(), month(), day(), hour(), minute(), second(), microsecond()}</pre>  <p>Converts <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> to the Calendar's datetime format.</p>    <h3 class="detail-header callback" id="c:naive_datetime_to_iso_days/7">  <h1 class="signature">naive_datetime_to_iso_days(year, month, day, hour, minute, second, microsecond)</h1>     </h3>
<pre data-language="elixir">naive_datetime_to_iso_days(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: iso_days()</pre>  <p>Converts the given datetime (without time zone) into the <a href="#t:iso_days/0"><code class="inline">iso_days/0</code></a> format.</p>    <h3 class="detail-header callback" id="c:naive_datetime_to_string/7">  <h1 class="signature">naive_datetime_to_string(year, month, day, hour, minute, second, microsecond)</h1>     </h3>
<pre data-language="elixir">naive_datetime_to_string(
  year(),
  month(),
  day(),
  hour(),
  minute(),
  second(),
  microsecond()
) :: String.t()</pre>  <p>Converts the datetime (without time zone) into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:quarter_of_year/3">  <h1 class="signature">quarter_of_year(year, month, day)</h1>     </h3>
<pre data-language="elixir">quarter_of_year(year(), month(), day()) :: non_neg_integer()</pre>  <p>Calculates the quarter of the year from the given <code class="inline">year</code>, <code class="inline">month</code>, and <code class="inline">day</code>.</p>    <h3 class="detail-header callback" id="c:time_from_day_fraction/1">  <h1 class="signature">time_from_day_fraction(day_fraction)</h1>     </h3>
<pre data-language="elixir">time_from_day_fraction(day_fraction()) ::
  {hour(), minute(), second(), microsecond()}</pre>  <p>Converts <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> to the Calendar's time format.</p>    <h3 class="detail-header callback" id="c:time_to_day_fraction/4">  <h1 class="signature">time_to_day_fraction(hour, minute, second, microsecond)</h1>     </h3>
<pre data-language="elixir">time_to_day_fraction(hour(), minute(), second(), microsecond()) ::
  day_fraction()</pre>  <p>Converts the given time to the <a href="#t:day_fraction/0"><code class="inline">day_fraction/0</code></a> format.</p>    <h3 class="detail-header callback" id="c:time_to_string/4">  <h1 class="signature">time_to_string(hour, minute, second, microsecond)</h1>     </h3>
<pre data-language="elixir">time_to_string(hour(), minute(), second(), microsecond()) :: String.t()</pre>  <p>Converts the time into a string according to the calendar.</p>    <h3 class="detail-header callback" id="c:valid_date?/3">  <h1 class="signature">valid_date?(year, month, day)</h1>     </h3>
<pre data-language="elixir">valid_date?(year(), month(), day()) :: boolean()</pre>  <p>Should return <code class="inline">true</code> if the given date describes a proper date in the calendar.</p>    <h3 class="detail-header callback" id="c:valid_time?/4">  <h1 class="signature">valid_time?(hour, minute, second, microsecond)</h1>     </h3>
<pre data-language="elixir">valid_time?(hour(), minute(), second(), microsecond()) :: boolean()</pre>  <p>Should return <code class="inline">true</code> if the given time describes a proper time in the calendar.</p>    <h3 class="detail-header callback" id="c:year_of_era/1">  <h1 class="signature">year_of_era(year)</h1>     </h3>
<pre data-language="elixir">year_of_era(year()) :: {year(), era()}</pre>  <p>Calculates the year and era from the given <code class="inline">year</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.9.1/Calendar.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.9.1/Calendar.html</a>
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
