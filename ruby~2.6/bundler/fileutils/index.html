
<!DOCTYPE HTML>

<html lang="en" class="_theme-default">

<head>
  <meta charset="utf-8">
  <title>Bundler&#58;&#58;FileUtils - Ruby 2.6 - W3cubDocs</title>
  
  <meta name="description" content=" Copyright © 2000-2007 Minero Aoki ">
  <meta name="keywords" content="module, bundler, fileutils, rb, -, ruby, ruby~2.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/ruby~2.6/bundler/fileutils/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" integrity="sha256-6/DH7X+2hvUPElJfGsvzm+tgIpmM9zjbYxnpsr6gR1A=" crossorigin="anonymous" href="/assets/application-ebf0c7ed7fb686f50f12525f1acbf39beb6022998cf738db6319e9b2bea04750.css">
  <script type="text/javascript" src="/assets/application-db285287b40ed28fac520fcfd75d7d874692b647b5b5e05968c741dda5de4148.js" integrity="sha256-2yhSh7QO0o+sUg/P1119h0aStke1teBZaMdB3aXeQUg=" crossorigin="anonymous"></script>
  <script src="/json/ruby~2.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-2572770204602497",
            enable_page_level_ads: true
        });
  </script>
  <script async custom-element="amp-auto-ads"
  src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
</script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/ruby~2.6/" class="_nav-link" title="" style="margin-left:0;">Ruby 2.6</a></span>
  
  <nav class="_nav">
    <a href="https://tools.w3cub.com/?_sp=docs" target="_blank" class="_nav-link ">W3cubTools</a>
    <a href="/cheatsheets/" class="_nav-link ">Cheatsheets</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="6861657091"
     data-ad-format="link"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			<div class="_page _rdoc">
				
				
<h1 id="module-Bundler::FileUtils" class="module"> module Bundler::FileUtils </h1>
<dl class="meta">
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../fileutils/streamutils_/">Bundler::FileUtils::StreamUtils_</a></dd>
</dl> <section class="description"> <h1 id="module-Bundler::FileUtils-label-fileutils.rb">fileutils.rb</h1> <p>Copyright © 2000-2007 Minero Aoki</p> <p>This program is free software. You can distribute/modify this program under the same terms of ruby.</p> <h2 id="module-Bundler::FileUtils-label-module+Bundler-3A-3AFileUtils">module <a href="../fileutils/"><code>Bundler::FileUtils</code></a>
</h2> <p>Namespace for several file utility methods for copying, moving, removing, etc.</p> <h3 id="module-Bundler::FileUtils-label-Module+Functions">
<a href="../../module/"><code>Module</code></a> Functions</h3> <pre class="ruby" data-language="ruby">require 'bundler/vendor/fileutils/lib/fileutils'

Bundler::FileUtils.cd(dir, options)
Bundler::FileUtils.cd(dir, options) {|dir| block }
Bundler::FileUtils.pwd()
Bundler::FileUtils.mkdir(dir, options)
Bundler::FileUtils.mkdir(list, options)
Bundler::FileUtils.mkdir_p(dir, options)
Bundler::FileUtils.mkdir_p(list, options)
Bundler::FileUtils.rmdir(dir, options)
Bundler::FileUtils.rmdir(list, options)
Bundler::FileUtils.ln(target, link, options)
Bundler::FileUtils.ln(targets, dir, options)
Bundler::FileUtils.ln_s(target, link, options)
Bundler::FileUtils.ln_s(targets, dir, options)
Bundler::FileUtils.ln_sf(target, link, options)
Bundler::FileUtils.cp(src, dest, options)
Bundler::FileUtils.cp(list, dir, options)
Bundler::FileUtils.cp_r(src, dest, options)
Bundler::FileUtils.cp_r(list, dir, options)
Bundler::FileUtils.mv(src, dest, options)
Bundler::FileUtils.mv(list, dir, options)
Bundler::FileUtils.rm(list, options)
Bundler::FileUtils.rm_r(list, options)
Bundler::FileUtils.rm_rf(list, options)
Bundler::FileUtils.install(src, dest, options)
Bundler::FileUtils.chmod(mode, list, options)
Bundler::FileUtils.chmod_R(mode, list, options)
Bundler::FileUtils.chown(user, group, list, options)
Bundler::FileUtils.chown_R(user, group, list, options)
Bundler::FileUtils.touch(list, options)
</pre> <p>The <code>options</code> parameter is a hash of options, taken from the list <code>:force</code>, <code>:noop</code>, <code>:preserve</code>, and <code>:verbose</code>. <code>:noop</code> means that no changes are made. The other three are obvious. Each method documents the options that it honours.</p> <p>All methods that have the concept of a “source” file or directory can take either one file or a list of files in that argument. See the method documentation for examples.</p> <p>There are some `low level' methods, which do not accept any option:</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.copy_entry(src, dest, preserve = false, dereference = false)
Bundler::FileUtils.copy_file(src, dest, preserve = false, dereference = true)
Bundler::FileUtils.copy_stream(srcstream, deststream)
Bundler::FileUtils.remove_entry(path, force = false)
Bundler::FileUtils.remove_entry_secure(path, force = false)
Bundler::FileUtils.remove_file(path, force = false)
Bundler::FileUtils.compare_file(path_a, path_b)
Bundler::FileUtils.compare_stream(stream_a, stream_b)
Bundler::FileUtils.uptodate?(file, cmp_list)
</pre> <h2 id="module-Bundler::FileUtils-label-module+Bundler-3A-3AFileUtils-3A-3AVerbose">module <a href="../fileutils/verbose/"><code>Bundler::FileUtils::Verbose</code></a>
</h2> <p>This module has all methods of <a href="../fileutils/"><code>Bundler::FileUtils</code></a> module, but it outputs messages before acting. This equates to passing the <code>:verbose</code> flag to methods in <a href="../fileutils/"><code>Bundler::FileUtils</code></a>.</p> <h2 id="module-Bundler::FileUtils-label-module+Bundler-3A-3AFileUtils-3A-3ANoWrite">module <a href="../fileutils/nowrite/"><code>Bundler::FileUtils::NoWrite</code></a>
</h2> <p>This module has all methods of <a href="../fileutils/"><code>Bundler::FileUtils</code></a> module, but never changes files/directories. This equates to passing the <code>:noop</code> flag to methods in <a href="../fileutils/"><code>Bundler::FileUtils</code></a>.</p> <h2 id="module-Bundler::FileUtils-label-module+Bundler-3A-3AFileUtils-3A-3ADryRun">module <a href="../fileutils/dryrun/"><code>Bundler::FileUtils::DryRun</code></a>
</h2> <p>This module has all methods of <a href="../fileutils/"><code>Bundler::FileUtils</code></a> module, but never changes files/directories. This equates to passing the <code>:noop</code> and <code>:verbose</code> flags to methods in <a href="../fileutils/"><code>Bundler::FileUtils</code></a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="LOW_METHODS">LOW_METHODS </dt>

<dt id="METHODS">METHODS </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-cd"> <span class="method-name">cd</span><span class="method-args">(dir, verbose: nil) { |dir| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cd-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 118
def cd(dir, verbose: nil, &amp;block) # :yield: dir
  fu_output_message "cd #{dir}" if verbose
  Dir.chdir(dir, &amp;block)
  fu_output_message 'cd -' if verbose and block
end</pre> </div> <p>Changes the current directory to the directory <code>dir</code>.</p> <p>If this method is called with block, resumes to the old working directory after the block execution finished.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cd('/', :verbose =&gt; true)   # chdir and report it

Bundler::FileUtils.cd('/') do  # chdir
  # ...               # do something
end                   # return to original directory
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-chdir">chdir</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-chdir"> <span class="method-name">chdir</span><span class="method-args">(dir, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-cd">cd</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-chmod"> <span class="method-name">chmod</span><span class="method-args">(mode, list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chmod-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 914
def chmod(mode, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod %s %s', mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |path|
    Entry_.new(path).chmod(fu_mode(mode, path))
  end
end</pre> </div> <p>Changes permission bits on the named files (in <code>list</code>) to the bit pattern represented by <code>mode</code>.</p> <p><code>mode</code> is the symbolic and absolute mode can be used.</p> <p>Absolute mode is</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod 0755, 'somecommand'
Bundler::FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)
Bundler::FileUtils.chmod 0755, '/usr/bin/ruby', :verbose =&gt; true
</pre> <p>Symbolic mode is</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod "u=wrx,go=rx", 'somecommand'
Bundler::FileUtils.chmod "u=wr,go=rr", %w(my.rb your.rb his.rb her.rb)
Bundler::FileUtils.chmod "u=wrx,go=rx", '/usr/bin/ruby', :verbose =&gt; true
</pre> <dl class="rdoc-list note-list">
<dt>“a” </dt>
<dd> <p>is user, group, other mask.</p> </dd>
<dt>“u” </dt>
<dd> <p>is user's mask.</p> </dd>
<dt>“g” </dt>
<dd> <p>is group's mask.</p> </dd>
<dt>“o” </dt>
<dd> <p>is other's mask.</p> </dd>
<dt>“w” </dt>
<dd> <p>is write permission.</p> </dd>
<dt>“r” </dt>
<dd> <p>is read permission.</p> </dd>
<dt>“x” </dt>
<dd> <p>is execute permission.</p> </dd>
<dt>“X” </dt>
<dd> <p>is execute permission for directories only, must be used in conjunction with “+”</p> </dd>
<dt>“s” </dt>
<dd> <p>is uid, gid.</p> </dd>
<dt>“t” </dt>
<dd> <p>is sticky bit.</p> </dd>
<dt>“+” </dt>
<dd> <p>is added to a class given the specified mode.</p> </dd>
<dt>“-” </dt>
<dd> <p>Is removed from a given class given mode.</p> </dd>
<dt>“=” </dt>
<dd> <p>Is the exact nature of the class will be given a specified mode.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-chmod_R"> <span class="method-name">chmod_R</span><span class="method-args">(mode, list, noop: nil, verbose: nil, force: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chmod_R-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 931
def chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod -R%s %s %s',
                            (force ? 'f' : ''),
                            mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chmod(fu_mode(mode, ent.path))
      rescue
        raise unless force
      end
    end
  end
end</pre> </div> <p>Changes permission bits on the named files (in <code>list</code>) to the bit pattern represented by <code>mode</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod_R 0700, "/tmp/app.#{$$}"
Bundler::FileUtils.chmod_R "u=wrx", "/tmp/app.#{$$}"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-chown"> <span class="method-name">chown</span><span class="method-args">(user, group, list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chown-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 959
def chown(user, group, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown %s %s',
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |path|
    Entry_.new(path).chown uid, gid
  end
end</pre> </div> <p>Changes owner and group on the named files (in <code>list</code>) to the user <code>user</code> and the group <code>group</code>. <code>user</code> and <code>group</code> may be an ID (Integer/String) or a name (String). If <code>user</code> or <code>group</code> is nil, this method does not change the attribute.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'
Bundler::FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-chown_R"> <span class="method-name">chown_R</span><span class="method-args">(user, group, list, noop: nil, verbose: nil, force: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chown_R-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 983
def chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown -R%s %s %s',
                            (force ? 'f' : ''),
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chown uid, gid
      rescue
        raise unless force
      end
    end
  end
end</pre> </div> <p>Changes owner and group on the named files (in <code>list</code>) to the user <code>user</code> and the group <code>group</code> recursively. <code>user</code> and <code>group</code> may be an ID (Integer/String) or a name (String). If <code>user</code> or <code>group</code> is nil, this method does not change the attribute.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chown_R 'www', 'www', '/var/www/htdocs'
Bundler::FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-cmp"> <span class="method-name">cmp</span><span class="method-args">(a, b)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-compare_file"> <span class="method-name">compare_file</span><span class="method-args">(a, b)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 725
def compare_file(a, b)
  return false unless File.size(a) == File.size(b)
  File.open(a, 'rb') {|fa|
    File.open(b, 'rb') {|fb|
      return compare_stream(fa, fb)
    }
  }
end</pre> </div> <p>Returns true if the contents of a file <code>a</code> and a file <code>b</code> are identical.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.compare_file('somefile', 'somefile')       #=&gt; true
Bundler::FileUtils.compare_file('/dev/null', '/dev/urandom')  #=&gt; false
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-identical-3F">identical?</a>, <a href="../fileutils/#method-i-cmp">cmp</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-compare_stream"> <span class="method-name">compare_stream</span><span class="method-args">(a, b)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_stream-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 743
def compare_stream(a, b)
  bsize = fu_stream_blksize(a, b)
  sa = String.new(capacity: bsize)
  sb = String.new(capacity: bsize)
  begin
    a.read(bsize, sa)
    b.read(bsize, sb)
    return true if sa.empty? &amp;&amp; sb.empty?
  end while sa == sb
  false
end</pre> </div> <p>Returns true if the contents of a stream <code>a</code> and <code>b</code> are identical.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-copy"> <span class="method-name">copy</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-cp">cp</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-copy_entry"> <span class="method-name">copy_entry</span><span class="method-args">(src, dest, preserve = false, dereference_root = false, remove_destination = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_entry-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 412
def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  Entry_.new(src, nil, dereference_root).wrap_traverse(proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; File.file?(destent.path)
    ent.copy destent.path
  end, proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    ent.copy_metadata destent.path if preserve
  end)
end</pre> </div> <p>Copies a file system entry <code>src</code> to <code>dest</code>. If <code>src</code> is a directory, this method copies its contents recursively. This method preserves file types, c.f. symlink, directory… (FIFO, device files and etc. are not supported yet)</p> <p>Both of <code>src</code> and <code>dest</code> must be a path name. <code>src</code> must exist, <code>dest</code> must not exist.</p> <p>If <code>preserve</code> is true, this method preserves owner, group, and modified time. Permissions are copied regardless <code>preserve</code>.</p> <p>If <code>dereference_root</code> is true, this method dereference tree root.</p> <p>If <code>remove_destination</code> is true, this method removes each destination file before copy.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-copy_file"> <span class="method-name">copy_file</span><span class="method-args">(src, dest, preserve = false, dereference = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 428
def copy_file(src, dest, preserve = false, dereference = true)
  ent = Entry_.new(src, nil, dereference)
  ent.copy_file dest
  ent.copy_metadata dest if preserve
end</pre> </div> <p>Copies file contents of <code>src</code> to <code>dest</code>. Both of <code>src</code> and <code>dest</code> must be a path name.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-copy_stream"> <span class="method-name">copy_stream</span><span class="method-args">(src, dest)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_stream-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 440
def copy_stream(src, dest)
  IO.copy_stream(src, dest)
end</pre> </div> <p>Copies stream <code>src</code> to <code>dest</code>. <code>src</code> must respond to read(n) and <code>dest</code> must respond to write(str).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-cp"> <span class="method-name">cp</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cp-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 353
def cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  fu_output_message "cp#{preserve ? ' -p' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_file s, d, preserve
  end
end</pre> </div> <p>Copies a file content <code>src</code> to <code>dest</code>. If <code>dest</code> is a directory, copies <code>src</code> to <code>dest/src</code>.</p> <p>If <code>src</code> is a list of files, then <code>dest</code> must be a directory.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cp 'eval.c', 'eval.c.org'
Bundler::FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'
Bundler::FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', :verbose =&gt; true
Bundler::FileUtils.cp 'symlink', 'dest'   # copy content, "dest" is not a symlink
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-copy">copy</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-cp_r"> <span class="method-name">cp_r</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cp_r-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 386
def cp_r(src, dest, preserve: nil, noop: nil, verbose: nil,
         dereference_root: true, remove_destination: nil)
  fu_output_message "cp -r#{preserve ? 'p' : ''}#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_entry s, d, preserve, dereference_root, remove_destination
  end
end</pre> </div> <p>Copies <code>src</code> to <code>dest</code>. If <code>src</code> is a directory, this method copies all its contents recursively. If <code>dest</code> is a directory, copies <code>src</code> to <code>dest/src</code>.</p> <p><code>src</code> can be a list of files.</p> <pre class="ruby" data-language="ruby"># Installing Ruby library "mylib" under the site_ruby
Bundler::FileUtils.rm_r site_ruby + '/mylib', :force
Bundler::FileUtils.cp_r 'lib/', site_ruby + '/mylib'

# Examples of copying several files to target directory.
Bundler::FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'
Bundler::FileUtils.cp_r Dir.glob('*.rb'), '/home/foo/lib/ruby', :noop =&gt; true, :verbose =&gt; true

# If you want to copy all contents of a directory instead of the
# directory itself, c.f. src/x -&gt; dest/x, src/y -&gt; dest/y,
# use following code.
Bundler::FileUtils.cp_r 'src/.', 'dest'     # cp_r('src', 'dest') makes dest/src,
                                   # but this doesn't.
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-getwd"> <span class="method-name">getwd</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-pwd">pwd</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-identical-3F"> <span class="method-name">identical?</span><span class="method-args">(a, b)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-install"> <span class="method-name">install</span><span class="method-args">(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="install-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 764
def install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil,
            noop: nil, verbose: nil)
  if verbose
    msg = +"install -c"
    msg &lt;&lt; ' -p' if preserve
    msg &lt;&lt; ' -m ' &lt;&lt; mode_to_s(mode) if mode
    msg &lt;&lt; " -o #{owner}" if owner
    msg &lt;&lt; " -g #{group}" if group
    msg &lt;&lt; ' ' &lt;&lt; [src,dest].flatten.join(' ')
    fu_output_message msg
  end
  return if noop
  uid = fu_get_uid(owner)
  gid = fu_get_gid(group)
  fu_each_src_dest(src, dest) do |s, d|
    st = File.stat(s)
    unless File.exist?(d) and compare_file(s, d)
      remove_file d, true
      copy_file s, d
      File.utime st.atime, st.mtime, d if preserve
      File.chmod fu_mode(mode, st), d if mode
      File.chown uid, gid, d if uid or gid
    end
  end
end</pre> </div> <p>If <code>src</code> is not same as <code>dest</code>, copies it and changes the permission mode to <code>mode</code>. If <code>dest</code> is a directory, destination is <code>dest</code>/<code>src</code>. This method removes destination before copy.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.install 'ruby', '/usr/local/bin/ruby', :mode =&gt; 0755, :verbose =&gt; true
Bundler::FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-link"> <span class="method-name">link</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-ln">ln</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ln"> <span class="method-callseq"> Bundler::FileUtils.ln(target, link, force: nil, noop: nil, verbose: nil) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln(target, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln(targets, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-description">
<div class="method-source-code" id="ln-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 283
def ln(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.link s, d
  end
end</pre> </div> <p>In the first form, creates a hard link <code>link</code> which points to <code>target</code>. If <code>link</code> already exists, raises Errno::EEXIST. But if the :force option is set, overwrites <code>link</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln 'gcc', 'cc', verbose: true
Bundler::FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'
</pre> <p>In the second form, creates a link <code>dir/target</code> pointing to <code>target</code>. In the third form, creates several hard links in the directory <code>dir</code>, pointing to each item in <code>targets</code>. If <code>dir</code> is not a directory, raises Errno::ENOTDIR.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cd '/sbin'
Bundler::FileUtils.ln %w(cp mv mkdir), '/bin'   # Now /sbin/cp and /bin/cp are linked.
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-link">link</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ln_s"> <span class="method-callseq"> Bundler::FileUtils.ln_s(target, link, force: nil, noop: nil, verbose: nil) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln_s(target, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln_s(targets, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-description">
<div class="method-source-code" id="ln_s-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 316
def ln_s(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln -s#{force ? 'f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.symlink s, d
  end
end</pre> </div> <p>In the first form, creates a symbolic link <code>link</code> which points to <code>target</code>. If <code>link</code> already exists, raises Errno::EEXIST. But if the :force option is set, overwrites <code>link</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'
Bundler::FileUtils.ln_s 'verylongsourcefilename.c', 'c', force: true
</pre> <p>In the second form, creates a link <code>dir/target</code> pointing to <code>target</code>. In the third form, creates several symbolic links in the directory <code>dir</code>, pointing to each item in <code>targets</code>. If <code>dir</code> is not a directory, raises Errno::ENOTDIR.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s Dir.glob('/bin/*.rb'), '/home/foo/bin'
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-symlink">symlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-ln_sf"> <span class="method-callseq"> Bundler::FileUtils.ln_sf(*args) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ln_sf-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 337
def ln_sf(src, dest, noop: nil, verbose: nil)
  ln_s src, dest, force: true, noop: noop, verbose: verbose
end</pre> </div> <p>Same as</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s(*args, force: true)
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-makedirs"> <span class="method-name">makedirs</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-mkdir"> <span class="method-name">mkdir</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mkdir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 160
def mkdir(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return if noop

  list.each do |dir|
    fu_mkdir dir, mode
  end
end</pre> </div> <p>Creates one or more directories.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mkdir 'test'
Bundler::FileUtils.mkdir %w( tmp data )
Bundler::FileUtils.mkdir 'notexist', :noop =&gt; true  # Does not really create.
Bundler::FileUtils.mkdir 'tmp', :mode =&gt; 0700
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-mkdir_p"> <span class="method-name">mkdir_p</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mkdir_p-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 186
def mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir -p #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return *list if noop

  list.map {|path| remove_trailing_slash(path)}.each do |path|
    # optimize for the most common case
    begin
      fu_mkdir path, mode
      next
    rescue SystemCallError
      next if File.directory?(path)
    end

    stack = []
    until path == stack.last   # dirname("/")=="/", dirname("C:/")=="C:/"
      stack.push path
      path = File.dirname(path)
    end
    stack.pop                 # root directory should exist
    stack.reverse_each do |dir|
      begin
        fu_mkdir dir, mode
      rescue SystemCallError
        raise unless File.directory?(dir)
      end
    end
  end

  return *list
end</pre> </div> <p>Creates a directory and all its parent directories. For example,</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mkdir_p '/usr/local/lib/ruby'
</pre> <p>causes to make following directories, if it does not exist.</p> <ul>
<li> <p>/usr</p> </li>
<li> <p>/usr/local</p> </li>
<li> <p>/usr/local/lib</p> </li>
<li> <p>/usr/local/lib/ruby</p> </li>
</ul> <p>You can pass several directories at a time in a list.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-mkpath">mkpath</a>, <a href="../fileutils/#method-i-makedirs">makedirs</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-mkpath"> <span class="method-name">mkpath</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-move"> <span class="method-name">move</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mv">mv</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-mv"> <span class="method-name">mv</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mv-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 455
def mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  fu_output_message "mv#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    destent = Entry_.new(d, nil, true)
    begin
      if destent.exist?
        if destent.directory?
          raise Errno::EEXIST, d
        else
          destent.remove_file if rename_cannot_overwrite_file?
        end
      end
      begin
        File.rename s, d
      rescue Errno::EXDEV
        copy_entry s, d, true
        if secure
          remove_entry_secure s, force
        else
          remove_entry s, force
        end
      end
    rescue SystemCallError
      raise unless force
    end
  end
end</pre> </div> <p>Moves file(s) <code>src</code> to <code>dest</code>. If <code>file</code> and <code>dest</code> exist on the different disk partition, the file is copied then the original file is removed.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mv 'badname.rb', 'goodname.rb'
Bundler::FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', :force =&gt; true  # no error

Bundler::FileUtils.mv %w(junk.txt dust.txt), '/home/foo/.trash/'
Bundler::FileUtils.mv Dir.glob('test*.rb'), 'test', :noop =&gt; true, :verbose =&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-move">move</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-pwd"> <span class="method-name">pwd</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pwd-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 98
def pwd
  Dir.pwd
end</pre> </div> <p>Returns the name of the current directory.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-getwd">getwd</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-remove"> <span class="method-name">remove</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm">rm</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-remove_dir"> <span class="method-name">remove_dir</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_dir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 714
def remove_dir(path, force = false)
  remove_entry path, force   # FIXME?? check if it is a directory
end</pre> </div> <p>Removes a directory <code>dir</code> and its contents recursively. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> if <code>force</code> is true.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-remove_entry"> <span class="method-name">remove_entry</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 686
def remove_entry(path, force = false)
  Entry_.new(path).postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div> <p>This method removes a file system entry <code>path</code>. <code>path</code> might be a regular file, a directory, or something. If <code>path</code> is a directory, remove it recursively.</p> <p>See also <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-remove_entry_secure"> <span class="method-name">remove_entry_secure</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry_secure-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 609
def remove_entry_secure(path, force = false)
  unless fu_have_symlink?
    remove_entry path, force
    return
  end
  fullpath = File.expand_path(path)
  st = File.lstat(fullpath)
  unless st.directory?
    File.unlink fullpath
    return
  end
  # is a directory.
  parent_st = File.stat(File.dirname(fullpath))
  unless parent_st.world_writable?
    remove_entry path, force
    return
  end
  unless parent_st.sticky?
    raise ArgumentError, "parent directory is world writable, Bundler::FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})"
  end
  # freeze tree root
  euid = Process.euid
  File.open(fullpath + '/.') {|f|
    unless fu_stat_identical_entry?(st, f.stat)
      # symlink (TOC-to-TOU attack?)
      File.unlink fullpath
      return
    end
    f.chown euid, -1
    f.chmod 0700
    unless fu_stat_identical_entry?(st, File.lstat(fullpath))
      # TOC-to-TOU attack?
      File.unlink fullpath
      return
    end
  }
  # ---- tree root is frozen ----
  root = Entry_.new(path)
  root.preorder_traverse do |ent|
    if ent.directory?
      ent.chown euid, -1
      ent.chmod 0700
    end
  end
  root.postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div> <p>This method removes a file system entry <code>path</code>. <code>path</code> shall be a regular file, a directory, or something. If <code>path</code> is a directory, remove it recursively. This method is required to avoid TOCTTOU (time-of-check-to-time-of-use) local security vulnerability of <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a>. <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a> causes security hole when:</p> <ul>
<li> <p>Parent directory is world writable (including /tmp).</p> </li>
<li> <p>Removing directory tree includes world writable directory.</p> </li>
<li> <p>The system has symbolic link.</p> </li>
</ul> <p>To avoid this security hole, this method applies special preprocess. If <code>path</code> is a directory, this method chown(2) and chmod(2) all removing directories. This requires the current process is the owner of the removing whole directory tree, or is the super user (root).</p> <p>WARNING: You must ensure that <strong>ALL</strong> parent directories cannot be moved by other untrusted users. For example, parent directories should not be owned by untrusted users, and should not be world writable except when the sticky bit set.</p> <p>WARNING: Only the owner of the removing directory tree, or Unix super user (root) should invoke this method. Otherwise this method does not work.</p> <p>For details of this security vulnerability, see Perl's case:</p> <ul>
<li> <p><a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448" target="_blank">www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448</a></p> </li>
<li> <p><a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452" target="_blank">www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452</a></p> </li>
</ul> <p>For fileutils.rb, this vulnerability is reported in [ruby-dev:26100].</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-remove_file"> <span class="method-name">remove_file</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 703
def remove_file(path, force = false)
  Entry_.new(path).remove_file
rescue
  raise unless force
end</pre> </div> <p>Removes a file <code>path</code>. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> if <code>force</code> is true.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rm"> <span class="method-name">rm</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 501
def rm(list, force: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rm#{force ? ' -f' : ''} #{list.join ' '}" if verbose
  return if noop

  list.each do |path|
    remove_file path, force
  end
end</pre> </div> <p>Remove file(s) specified in <code>list</code>. This method cannot remove directories. All StandardErrors are ignored when the :force option is set.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm %w( junk.txt dust.txt )
Bundler::FileUtils.rm Dir.glob('*.so')
Bundler::FileUtils.rm 'NotExistFile', :force =&gt; true   # never raises exception
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rm_f"> <span class="method-name">rm_f</span><span class="method-args">(list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_f-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 520
def rm_f(list, noop: nil, verbose: nil)
  rm list, force: true, noop: noop, verbose: verbose
end</pre> </div> <p>Equivalent to</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm(list, :force =&gt; true)
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-safe_unlink">safe_unlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rm_r"> <span class="method-name">rm_r</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_r-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 547
def rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  list = fu_list(list)
  fu_output_message "rm -r#{force ? 'f' : ''} #{list.join ' '}" if verbose
  return if noop
  list.each do |path|
    if secure
      remove_entry_secure path, force
    else
      remove_entry path, force
    end
  end
end</pre> </div> <p>remove files <code>list[0]</code> <code>list[1]</code>… If <code>list[n]</code> is a directory, removes its all contents recursively. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> when :force option is set.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm_r Dir.glob('/tmp/*')
Bundler::FileUtils.rm_r 'some_dir', :force =&gt; true
</pre> <p>WARNING: This method causes local vulnerability if one of parent directories or removing directory tree are world writable (including /tmp, whose permission is 1777), and the current process has strong privilege such as Unix super user (root), and the system has symbolic link. For secure removing, read the documentation of <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a> carefully, and set :secure option to true. Default is :secure=&gt;false.</p> <p>NOTE: This method calls <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a> if :secure option is set. See also <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rm_rf"> <span class="method-name">rm_rf</span><span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_rf-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 569
def rm_rf(list, noop: nil, verbose: nil, secure: nil)
  rm_r list, force: true, noop: noop, verbose: verbose, secure: secure
end</pre> </div> <p>Equivalent to</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm_r(list, :force =&gt; true)
</pre> <p>WARNING: This method causes local vulnerability. Read the documentation of <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a> first.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-rmtree">rmtree</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-rmdir"> <span class="method-name">rmdir</span><span class="method-args">(list, parents: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rmdir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 243
def rmdir(list, parents: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rmdir #{parents ? '-p ' : ''}#{list.join ' '}" if verbose
  return if noop
  list.each do |dir|
    begin
      Dir.rmdir(dir = remove_trailing_slash(dir))
      if parents
        until (parent = File.dirname(dir)) == '.' or parent == dir
          dir = parent
          Dir.rmdir(dir)
        end
      end
    rescue Errno::ENOTEMPTY, Errno::EEXIST, Errno::ENOENT
    end
  end
end</pre> </div> <p>Removes one or more directories.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rmdir 'somedir'
Bundler::FileUtils.rmdir %w(somedir anydir otherdir)
# Does not really remove directory; outputs message.
Bundler::FileUtils.rmdir 'somedir', :verbose =&gt; true, :noop =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-rmtree"> <span class="method-name">rmtree</span><span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm_rf">rm_rf</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-safe_unlink"> <span class="method-name">safe_unlink</span><span class="method-args">(list, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm_f">rm_f</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-c-symlink"> <span class="method-name">symlink</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-ln_s">ln_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-touch"> <span class="method-name">touch</span><span class="method-args">(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="touch-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1042
def touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  list = fu_list(list)
  t = mtime
  if verbose
    fu_output_message "touch #{nocreate ? '-c ' : ''}#{t ? t.strftime('-t %Y%m%d%H%M.%S ') : ''}#{list.join ' '}"
  end
  return if noop
  list.each do |path|
    created = nocreate
    begin
      File.utime(t, t, path)
    rescue Errno::ENOENT
      raise if created
      File.open(path, 'a') {
        ;
      }
      created = true
      retry if t
    end
  end
end</pre> </div> <p>Updates modification time (mtime) and access time (atime) of file(s) in <code>list</code>. Files are created if they don't exist.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.touch 'timestamp'
Bundler::FileUtils.touch Dir.glob('*.c');  system 'make'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-uptodate-3F"> <span class="method-name">uptodate?</span><span class="method-args">(new, old_list)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="uptodate-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 135
def uptodate?(new, old_list)
  return false unless File.exist?(new)
  new_time = File.mtime(new)
  old_list.each do |old|
    if File.exist?(old)
      return false unless new_time &gt; File.mtime(old)
    end
  end
  true
end</pre> </div> <p>Returns true if <code>new</code> is newer than all <code>old_list</code>. Non-existent files are older than any file.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \
    system 'make hello.o'
</pre>  </div> </div> </section> <section id="private-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-collect_method"> <span class="method-name">collect_method</span><span class="method-args">(opt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="collect_method-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1549
def self.collect_method(opt)
  OPT_TABLE.keys.select {|m| OPT_TABLE[m].include?(opt) }
end</pre> </div> <p>Returns an <a href="../../array/"><code>Array</code></a> of method names which have the option <code>opt</code>.</p> <pre class="ruby" data-language="ruby">p Bundler::FileUtils.collect_method(:preserve) #=&gt; ["cp", "cp_r", "copy", "install"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-commands"> <span class="method-name">commands</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="commands-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1510
def self.commands
  OPT_TABLE.keys
end</pre> </div> <p>Returns an <a href="../../array/"><code>Array</code></a> of method names which have any options.</p> <pre class="ruby" data-language="ruby">p Bundler::FileUtils.commands  #=&gt; ["chmod", "cp", "cp_r", "install", ...]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-have_option-3F"> <span class="method-name">have_option?</span><span class="method-args">(mid, opt)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="have_option-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1530
def self.have_option?(mid, opt)
  li = OPT_TABLE[mid.to_s] or raise ArgumentError, "no such method: #{mid}"
  li.include?(opt)
end</pre> </div> <p>Returns true if the method <code>mid</code> have an option <code>opt</code>.</p> <pre class="ruby" data-language="ruby">p Bundler::FileUtils.have_option?(:cp, :noop)     #=&gt; true
p Bundler::FileUtils.have_option?(:rm, :force)    #=&gt; true
p Bundler::FileUtils.have_option?(:rm, :preserve) #=&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-options"> <span class="method-name">options</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1519
def self.options
  OPT_TABLE.values.flatten.uniq.map {|sym| sym.to_s }
end</pre> </div> <p>Returns an <a href="../../array/"><code>Array</code></a> of option names.</p> <pre class="ruby" data-language="ruby">p Bundler::FileUtils.options  #=&gt; ["noop", "force", "verbose", "preserve", "mode"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-c-options_of"> <span class="method-name">options_of</span><span class="method-args">(mid)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="options_of-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1540
def self.options_of(mid)
  OPT_TABLE[mid.to_s].map {|sym| sym.to_s }
end</pre> </div> <p>Returns an <a href="../../array/"><code>Array</code></a> of option names of the method <code>mid</code>.</p> <pre class="ruby" data-language="ruby">p Bundler::FileUtils.options_of(:rm)  #=&gt; ["noop", "verbose", "force"]
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-cd"> <span class="method-name">cd</span><span class="method-args">(dir, verbose: nil) { |dir| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cd-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 118
def cd(dir, verbose: nil, &amp;block) # :yield: dir
  fu_output_message "cd #{dir}" if verbose
  Dir.chdir(dir, &amp;block)
  fu_output_message 'cd -' if verbose and block
end</pre> </div> <p>Changes the current directory to the directory <code>dir</code>.</p> <p>If this method is called with block, resumes to the old working directory after the block execution finished.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cd('/', :verbose =&gt; true)   # chdir and report it

Bundler::FileUtils.cd('/') do  # chdir
  # ...               # do something
end                   # return to original directory
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-chdir">chdir</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-chdir"> <span class="method-name">chdir</span><span class="method-args">(dir, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-cd">cd</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chmod"> <span class="method-name">chmod</span><span class="method-args">(mode, list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chmod-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 914
def chmod(mode, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod %s %s', mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |path|
    Entry_.new(path).chmod(fu_mode(mode, path))
  end
end</pre> </div> <p>Changes permission bits on the named files (in <code>list</code>) to the bit pattern represented by <code>mode</code>.</p> <p><code>mode</code> is the symbolic and absolute mode can be used.</p> <p>Absolute mode is</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod 0755, 'somecommand'
Bundler::FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)
Bundler::FileUtils.chmod 0755, '/usr/bin/ruby', :verbose =&gt; true
</pre> <p>Symbolic mode is</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod "u=wrx,go=rx", 'somecommand'
Bundler::FileUtils.chmod "u=wr,go=rr", %w(my.rb your.rb his.rb her.rb)
Bundler::FileUtils.chmod "u=wrx,go=rx", '/usr/bin/ruby', :verbose =&gt; true
</pre> <dl class="rdoc-list note-list">
<dt>“a” </dt>
<dd> <p>is user, group, other mask.</p> </dd>
<dt>“u” </dt>
<dd> <p>is user's mask.</p> </dd>
<dt>“g” </dt>
<dd> <p>is group's mask.</p> </dd>
<dt>“o” </dt>
<dd> <p>is other's mask.</p> </dd>
<dt>“w” </dt>
<dd> <p>is write permission.</p> </dd>
<dt>“r” </dt>
<dd> <p>is read permission.</p> </dd>
<dt>“x” </dt>
<dd> <p>is execute permission.</p> </dd>
<dt>“X” </dt>
<dd> <p>is execute permission for directories only, must be used in conjunction with “+”</p> </dd>
<dt>“s” </dt>
<dd> <p>is uid, gid.</p> </dd>
<dt>“t” </dt>
<dd> <p>is sticky bit.</p> </dd>
<dt>“+” </dt>
<dd> <p>is added to a class given the specified mode.</p> </dd>
<dt>“-” </dt>
<dd> <p>Is removed from a given class given mode.</p> </dd>
<dt>“=” </dt>
<dd> <p>Is the exact nature of the class will be given a specified mode.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chmod_R"> <span class="method-name">chmod_R</span><span class="method-args">(mode, list, noop: nil, verbose: nil, force: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chmod_R-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 931
def chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod -R%s %s %s',
                            (force ? 'f' : ''),
                            mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chmod(fu_mode(mode, ent.path))
      rescue
        raise unless force
      end
    end
  end
end</pre> </div> <p>Changes permission bits on the named files (in <code>list</code>) to the bit pattern represented by <code>mode</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chmod_R 0700, "/tmp/app.#{$$}"
Bundler::FileUtils.chmod_R "u=wrx", "/tmp/app.#{$$}"
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chown"> <span class="method-name">chown</span><span class="method-args">(user, group, list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chown-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 959
def chown(user, group, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown %s %s',
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |path|
    Entry_.new(path).chown uid, gid
  end
end</pre> </div> <p>Changes owner and group on the named files (in <code>list</code>) to the user <code>user</code> and the group <code>group</code>. <code>user</code> and <code>group</code> may be an ID (Integer/String) or a name (String). If <code>user</code> or <code>group</code> is nil, this method does not change the attribute.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'
Bundler::FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-chown_R"> <span class="method-name">chown_R</span><span class="method-args">(user, group, list, noop: nil, verbose: nil, force: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="chown_R-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 983
def chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown -R%s %s %s',
                            (force ? 'f' : ''),
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chown uid, gid
      rescue
        raise unless force
      end
    end
  end
end</pre> </div> <p>Changes owner and group on the named files (in <code>list</code>) to the user <code>user</code> and the group <code>group</code> recursively. <code>user</code> and <code>group</code> may be an ID (Integer/String) or a name (String). If <code>user</code> or <code>group</code> is nil, this method does not change the attribute.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.chown_R 'www', 'www', '/var/www/htdocs'
Bundler::FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-cmp"> <span class="method-name">cmp</span><span class="method-args">(a, b)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_file"> <span class="method-name">compare_file</span><span class="method-args">(a, b)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 725
def compare_file(a, b)
  return false unless File.size(a) == File.size(b)
  File.open(a, 'rb') {|fa|
    File.open(b, 'rb') {|fb|
      return compare_stream(fa, fb)
    }
  }
end</pre> </div> <p>Returns true if the contents of a file <code>a</code> and a file <code>b</code> are identical.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.compare_file('somefile', 'somefile')       #=&gt; true
Bundler::FileUtils.compare_file('/dev/null', '/dev/urandom')  #=&gt; false
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-identical-3F">identical?</a>, <a href="../fileutils/#method-i-cmp">cmp</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-compare_stream"> <span class="method-name">compare_stream</span><span class="method-args">(a, b)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="compare_stream-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 743
def compare_stream(a, b)
  bsize = fu_stream_blksize(a, b)
  sa = String.new(capacity: bsize)
  sb = String.new(capacity: bsize)
  begin
    a.read(bsize, sa)
    b.read(bsize, sb)
    return true if sa.empty? &amp;&amp; sb.empty?
  end while sa == sb
  false
end</pre> </div> <p>Returns true if the contents of a stream <code>a</code> and <code>b</code> are identical.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-copy"> <span class="method-name">copy</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-cp">cp</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-copy_entry"> <span class="method-name">copy_entry</span><span class="method-args">(src, dest, preserve = false, dereference_root = false, remove_destination = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_entry-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 412
def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  Entry_.new(src, nil, dereference_root).wrap_traverse(proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; File.file?(destent.path)
    ent.copy destent.path
  end, proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    ent.copy_metadata destent.path if preserve
  end)
end</pre> </div> <p>Copies a file system entry <code>src</code> to <code>dest</code>. If <code>src</code> is a directory, this method copies its contents recursively. This method preserves file types, c.f. symlink, directory… (FIFO, device files and etc. are not supported yet)</p> <p>Both of <code>src</code> and <code>dest</code> must be a path name. <code>src</code> must exist, <code>dest</code> must not exist.</p> <p>If <code>preserve</code> is true, this method preserves owner, group, and modified time. Permissions are copied regardless <code>preserve</code>.</p> <p>If <code>dereference_root</code> is true, this method dereference tree root.</p> <p>If <code>remove_destination</code> is true, this method removes each destination file before copy.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-copy_file"> <span class="method-name">copy_file</span><span class="method-args">(src, dest, preserve = false, dereference = true)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 428
def copy_file(src, dest, preserve = false, dereference = true)
  ent = Entry_.new(src, nil, dereference)
  ent.copy_file dest
  ent.copy_metadata dest if preserve
end</pre> </div> <p>Copies file contents of <code>src</code> to <code>dest</code>. Both of <code>src</code> and <code>dest</code> must be a path name.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-copy_stream"> <span class="method-name">copy_stream</span><span class="method-args">(src, dest)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="copy_stream-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 440
def copy_stream(src, dest)
  IO.copy_stream(src, dest)
end</pre> </div> <p>Copies stream <code>src</code> to <code>dest</code>. <code>src</code> must respond to read(n) and <code>dest</code> must respond to write(str).</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cp"> <span class="method-name">cp</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cp-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 353
def cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  fu_output_message "cp#{preserve ? ' -p' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_file s, d, preserve
  end
end</pre> </div> <p>Copies a file content <code>src</code> to <code>dest</code>. If <code>dest</code> is a directory, copies <code>src</code> to <code>dest/src</code>.</p> <p>If <code>src</code> is a list of files, then <code>dest</code> must be a directory.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cp 'eval.c', 'eval.c.org'
Bundler::FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'
Bundler::FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', :verbose =&gt; true
Bundler::FileUtils.cp 'symlink', 'dest'   # copy content, "dest" is not a symlink
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-copy">copy</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cp_r"> <span class="method-name">cp_r</span><span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="cp_r-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 386
def cp_r(src, dest, preserve: nil, noop: nil, verbose: nil,
         dereference_root: true, remove_destination: nil)
  fu_output_message "cp -r#{preserve ? 'p' : ''}#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_entry s, d, preserve, dereference_root, remove_destination
  end
end</pre> </div> <p>Copies <code>src</code> to <code>dest</code>. If <code>src</code> is a directory, this method copies all its contents recursively. If <code>dest</code> is a directory, copies <code>src</code> to <code>dest/src</code>.</p> <p><code>src</code> can be a list of files.</p> <pre class="ruby" data-language="ruby"># Installing Ruby library "mylib" under the site_ruby
Bundler::FileUtils.rm_r site_ruby + '/mylib', :force
Bundler::FileUtils.cp_r 'lib/', site_ruby + '/mylib'

# Examples of copying several files to target directory.
Bundler::FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'
Bundler::FileUtils.cp_r Dir.glob('*.rb'), '/home/foo/lib/ruby', :noop =&gt; true, :verbose =&gt; true

# If you want to copy all contents of a directory instead of the
# directory itself, c.f. src/x -&gt; dest/x, src/y -&gt; dest/y,
# use following code.
Bundler::FileUtils.cp_r 'src/.', 'dest'     # cp_r('src', 'dest') makes dest/src,
                                   # but this doesn't.
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-getwd"> <span class="method-name">getwd</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-pwd">pwd</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-identical-3F"> <span class="method-name">identical?</span><span class="method-args">(a, b)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-install"> <span class="method-name">install</span><span class="method-args">(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="install-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 764
def install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil,
            noop: nil, verbose: nil)
  if verbose
    msg = +"install -c"
    msg &lt;&lt; ' -p' if preserve
    msg &lt;&lt; ' -m ' &lt;&lt; mode_to_s(mode) if mode
    msg &lt;&lt; " -o #{owner}" if owner
    msg &lt;&lt; " -g #{group}" if group
    msg &lt;&lt; ' ' &lt;&lt; [src,dest].flatten.join(' ')
    fu_output_message msg
  end
  return if noop
  uid = fu_get_uid(owner)
  gid = fu_get_gid(group)
  fu_each_src_dest(src, dest) do |s, d|
    st = File.stat(s)
    unless File.exist?(d) and compare_file(s, d)
      remove_file d, true
      copy_file s, d
      File.utime st.atime, st.mtime, d if preserve
      File.chmod fu_mode(mode, st), d if mode
      File.chown uid, gid, d if uid or gid
    end
  end
end</pre> </div> <p>If <code>src</code> is not same as <code>dest</code>, copies it and changes the permission mode to <code>mode</code>. If <code>dest</code> is a directory, destination is <code>dest</code>/<code>src</code>. This method removes destination before copy.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.install 'ruby', '/usr/local/bin/ruby', :mode =&gt; 0755, :verbose =&gt; true
Bundler::FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', :verbose =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-link"> <span class="method-name">link</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-ln">ln</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ln"> <span class="method-callseq"> Bundler::FileUtils.ln(target, link, force: nil, noop: nil, verbose: nil) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln(target, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln(targets, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-description">
<div class="method-source-code" id="ln-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 283
def ln(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.link s, d
  end
end</pre> </div> <p>In the first form, creates a hard link <code>link</code> which points to <code>target</code>. If <code>link</code> already exists, raises Errno::EEXIST. But if the :force option is set, overwrites <code>link</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln 'gcc', 'cc', verbose: true
Bundler::FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'
</pre> <p>In the second form, creates a link <code>dir/target</code> pointing to <code>target</code>. In the third form, creates several hard links in the directory <code>dir</code>, pointing to each item in <code>targets</code>. If <code>dir</code> is not a directory, raises Errno::ENOTDIR.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.cd '/sbin'
Bundler::FileUtils.ln %w(cp mv mkdir), '/bin'   # Now /sbin/cp and /bin/cp are linked.
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-link">link</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ln_s"> <span class="method-callseq"> Bundler::FileUtils.ln_s(target, link, force: nil, noop: nil, verbose: nil) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln_s(target, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-heading"> <span class="method-callseq"> Bundler::FileUtils.ln_s(targets, dir, force: nil, noop: nil, verbose: nil) </span> </div> <div class="method-description">
<div class="method-source-code" id="ln_s-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 316
def ln_s(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln -s#{force ? 'f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.symlink s, d
  end
end</pre> </div> <p>In the first form, creates a symbolic link <code>link</code> which points to <code>target</code>. If <code>link</code> already exists, raises Errno::EEXIST. But if the :force option is set, overwrites <code>link</code>.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'
Bundler::FileUtils.ln_s 'verylongsourcefilename.c', 'c', force: true
</pre> <p>In the second form, creates a link <code>dir/target</code> pointing to <code>target</code>. In the third form, creates several symbolic links in the directory <code>dir</code>, pointing to each item in <code>targets</code>. If <code>dir</code> is not a directory, raises Errno::ENOTDIR.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s Dir.glob('/bin/*.rb'), '/home/foo/bin'
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-symlink">symlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ln_sf"> <span class="method-callseq"> Bundler::FileUtils.ln_sf(*args) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="ln_sf-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 337
def ln_sf(src, dest, noop: nil, verbose: nil)
  ln_s src, dest, force: true, noop: noop, verbose: verbose
end</pre> </div> <p>Same as</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.ln_s(*args, force: true)
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-makedirs"> <span class="method-name">makedirs</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mkdir"> <span class="method-name">mkdir</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mkdir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 160
def mkdir(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return if noop

  list.each do |dir|
    fu_mkdir dir, mode
  end
end</pre> </div> <p>Creates one or more directories.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mkdir 'test'
Bundler::FileUtils.mkdir %w( tmp data )
Bundler::FileUtils.mkdir 'notexist', :noop =&gt; true  # Does not really create.
Bundler::FileUtils.mkdir 'tmp', :mode =&gt; 0700
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mkdir_p"> <span class="method-name">mkdir_p</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mkdir_p-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 186
def mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir -p #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return *list if noop

  list.map {|path| remove_trailing_slash(path)}.each do |path|
    # optimize for the most common case
    begin
      fu_mkdir path, mode
      next
    rescue SystemCallError
      next if File.directory?(path)
    end

    stack = []
    until path == stack.last   # dirname("/")=="/", dirname("C:/")=="C:/"
      stack.push path
      path = File.dirname(path)
    end
    stack.pop                 # root directory should exist
    stack.reverse_each do |dir|
      begin
        fu_mkdir dir, mode
      rescue SystemCallError
        raise unless File.directory?(dir)
      end
    end
  end

  return *list
end</pre> </div> <p>Creates a directory and all its parent directories. For example,</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mkdir_p '/usr/local/lib/ruby'
</pre> <p>causes to make following directories, if it does not exist.</p> <ul>
<li> <p>/usr</p> </li>
<li> <p>/usr/local</p> </li>
<li> <p>/usr/local/lib</p> </li>
<li> <p>/usr/local/lib/ruby</p> </li>
</ul> <p>You can pass several directories at a time in a list.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-mkpath">mkpath</a>, <a href="../fileutils/#method-i-makedirs">makedirs</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-mkpath"> <span class="method-name">mkpath</span><span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-move"> <span class="method-name">move</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-mv">mv</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-mv"> <span class="method-name">mv</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="mv-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 455
def mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  fu_output_message "mv#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    destent = Entry_.new(d, nil, true)
    begin
      if destent.exist?
        if destent.directory?
          raise Errno::EEXIST, d
        else
          destent.remove_file if rename_cannot_overwrite_file?
        end
      end
      begin
        File.rename s, d
      rescue Errno::EXDEV
        copy_entry s, d, true
        if secure
          remove_entry_secure s, force
        else
          remove_entry s, force
        end
      end
    rescue SystemCallError
      raise unless force
    end
  end
end</pre> </div> <p>Moves file(s) <code>src</code> to <code>dest</code>. If <code>file</code> and <code>dest</code> exist on the different disk partition, the file is copied then the original file is removed.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.mv 'badname.rb', 'goodname.rb'
Bundler::FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', :force =&gt; true  # no error

Bundler::FileUtils.mv %w(junk.txt dust.txt), '/home/foo/.trash/'
Bundler::FileUtils.mv Dir.glob('test*.rb'), 'test', :noop =&gt; true, :verbose =&gt; true
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-move">move</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pwd"> <span class="method-name">pwd</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="pwd-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 98
def pwd
  Dir.pwd
end</pre> </div> <p>Returns the name of the current directory.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-getwd">getwd</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm">rm</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_dir"> <span class="method-name">remove_dir</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_dir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 714
def remove_dir(path, force = false)
  remove_entry path, force   # FIXME?? check if it is a directory
end</pre> </div> <p>Removes a directory <code>dir</code> and its contents recursively. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> if <code>force</code> is true.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_entry"> <span class="method-name">remove_entry</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 686
def remove_entry(path, force = false)
  Entry_.new(path).postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div> <p>This method removes a file system entry <code>path</code>. <code>path</code> might be a regular file, a directory, or something. If <code>path</code> is a directory, remove it recursively.</p> <p>See also <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_entry_secure"> <span class="method-name">remove_entry_secure</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry_secure-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 609
def remove_entry_secure(path, force = false)
  unless fu_have_symlink?
    remove_entry path, force
    return
  end
  fullpath = File.expand_path(path)
  st = File.lstat(fullpath)
  unless st.directory?
    File.unlink fullpath
    return
  end
  # is a directory.
  parent_st = File.stat(File.dirname(fullpath))
  unless parent_st.world_writable?
    remove_entry path, force
    return
  end
  unless parent_st.sticky?
    raise ArgumentError, "parent directory is world writable, Bundler::FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})"
  end
  # freeze tree root
  euid = Process.euid
  File.open(fullpath + '/.') {|f|
    unless fu_stat_identical_entry?(st, f.stat)
      # symlink (TOC-to-TOU attack?)
      File.unlink fullpath
      return
    end
    f.chown euid, -1
    f.chmod 0700
    unless fu_stat_identical_entry?(st, File.lstat(fullpath))
      # TOC-to-TOU attack?
      File.unlink fullpath
      return
    end
  }
  # ---- tree root is frozen ----
  root = Entry_.new(path)
  root.preorder_traverse do |ent|
    if ent.directory?
      ent.chown euid, -1
      ent.chmod 0700
    end
  end
  root.postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div> <p>This method removes a file system entry <code>path</code>. <code>path</code> shall be a regular file, a directory, or something. If <code>path</code> is a directory, remove it recursively. This method is required to avoid TOCTTOU (time-of-check-to-time-of-use) local security vulnerability of <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a>. <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a> causes security hole when:</p> <ul>
<li> <p>Parent directory is world writable (including /tmp).</p> </li>
<li> <p>Removing directory tree includes world writable directory.</p> </li>
<li> <p>The system has symbolic link.</p> </li>
</ul> <p>To avoid this security hole, this method applies special preprocess. If <code>path</code> is a directory, this method chown(2) and chmod(2) all removing directories. This requires the current process is the owner of the removing whole directory tree, or is the super user (root).</p> <p>WARNING: You must ensure that <strong>ALL</strong> parent directories cannot be moved by other untrusted users. For example, parent directories should not be owned by untrusted users, and should not be world writable except when the sticky bit set.</p> <p>WARNING: Only the owner of the removing directory tree, or Unix super user (root) should invoke this method. Otherwise this method does not work.</p> <p>For details of this security vulnerability, see Perl's case:</p> <ul>
<li> <p><a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448" target="_blank">www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448</a></p> </li>
<li> <p><a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452" target="_blank">www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452</a></p> </li>
</ul> <p>For fileutils.rb, this vulnerability is reported in [ruby-dev:26100].</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_file"> <span class="method-name">remove_file</span><span class="method-args">(path, force = false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="remove_file-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 703
def remove_file(path, force = false)
  Entry_.new(path).remove_file
rescue
  raise unless force
end</pre> </div> <p>Removes a file <code>path</code>. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> if <code>force</code> is true.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rm"> <span class="method-name">rm</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 501
def rm(list, force: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rm#{force ? ' -f' : ''} #{list.join ' '}" if verbose
  return if noop

  list.each do |path|
    remove_file path, force
  end
end</pre> </div> <p>Remove file(s) specified in <code>list</code>. This method cannot remove directories. All StandardErrors are ignored when the :force option is set.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm %w( junk.txt dust.txt )
Bundler::FileUtils.rm Dir.glob('*.so')
Bundler::FileUtils.rm 'NotExistFile', :force =&gt; true   # never raises exception
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rm_f"> <span class="method-name">rm_f</span><span class="method-args">(list, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_f-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 520
def rm_f(list, noop: nil, verbose: nil)
  rm list, force: true, noop: noop, verbose: verbose
end</pre> </div> <p>Equivalent to</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm(list, :force =&gt; true)
</pre>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-safe_unlink">safe_unlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rm_r"> <span class="method-name">rm_r</span><span class="method-args">(list, force: nil, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_r-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 547
def rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  list = fu_list(list)
  fu_output_message "rm -r#{force ? 'f' : ''} #{list.join ' '}" if verbose
  return if noop
  list.each do |path|
    if secure
      remove_entry_secure path, force
    else
      remove_entry path, force
    end
  end
end</pre> </div> <p>remove files <code>list[0]</code> <code>list[1]</code>… If <code>list[n]</code> is a directory, removes its all contents recursively. This method ignores <a href="../../standarderror/"><code>StandardError</code></a> when :force option is set.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm_r Dir.glob('/tmp/*')
Bundler::FileUtils.rm_r 'some_dir', :force =&gt; true
</pre> <p>WARNING: This method causes local vulnerability if one of parent directories or removing directory tree are world writable (including /tmp, whose permission is 1777), and the current process has strong privilege such as Unix super user (root), and the system has symbolic link. For secure removing, read the documentation of <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a> carefully, and set :secure option to true. Default is :secure=&gt;false.</p> <p>NOTE: This method calls <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a> if :secure option is set. See also <a href="../fileutils/#method-i-remove_entry_secure"><code>remove_entry_secure</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rm_rf"> <span class="method-name">rm_rf</span><span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rm_rf-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 569
def rm_rf(list, noop: nil, verbose: nil, secure: nil)
  rm_r list, force: true, noop: noop, verbose: verbose, secure: secure
end</pre> </div> <p>Equivalent to</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rm_r(list, :force =&gt; true)
</pre> <p>WARNING: This method causes local vulnerability. Read the documentation of <a href="../fileutils/#method-i-rm_r"><code>rm_r</code></a> first.</p>  </div> <div class="aliases"> Also aliased as: <a href="../fileutils/#method-i-rmtree">rmtree</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-rmdir"> <span class="method-name">rmdir</span><span class="method-args">(list, parents: nil, noop: nil, verbose: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="rmdir-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 243
def rmdir(list, parents: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rmdir #{parents ? '-p ' : ''}#{list.join ' '}" if verbose
  return if noop
  list.each do |dir|
    begin
      Dir.rmdir(dir = remove_trailing_slash(dir))
      if parents
        until (parent = File.dirname(dir)) == '.' or parent == dir
          dir = parent
          Dir.rmdir(dir)
        end
      end
    rescue Errno::ENOTEMPTY, Errno::EEXIST, Errno::ENOENT
    end
  end
end</pre> </div> <p>Removes one or more directories.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.rmdir 'somedir'
Bundler::FileUtils.rmdir %w(somedir anydir otherdir)
# Does not really remove directory; outputs message.
Bundler::FileUtils.rmdir 'somedir', :verbose =&gt; true, :noop =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-rmtree"> <span class="method-name">rmtree</span><span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm_rf">rm_rf</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-safe_unlink"> <span class="method-name">safe_unlink</span><span class="method-args">(list, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-rm_f">rm_f</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-symlink"> <span class="method-name">symlink</span><span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </div>  <div class="aliases"> Alias for: <a href="../fileutils/#method-i-ln_s">ln_s</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-touch"> <span class="method-name">touch</span><span class="method-args">(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="touch-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 1042
def touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  list = fu_list(list)
  t = mtime
  if verbose
    fu_output_message "touch #{nocreate ? '-c ' : ''}#{t ? t.strftime('-t %Y%m%d%H%M.%S ') : ''}#{list.join ' '}"
  end
  return if noop
  list.each do |path|
    created = nocreate
    begin
      File.utime(t, t, path)
    rescue Errno::ENOENT
      raise if created
      File.open(path, 'a') {
        ;
      }
      created = true
      retry if t
    end
  end
end</pre> </div> <p>Updates modification time (mtime) and access time (atime) of file(s) in <code>list</code>. Files are created if they don't exist.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.touch 'timestamp'
Bundler::FileUtils.touch Dir.glob('*.c');  system 'make'
</pre>  </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-uptodate-3F"> <span class="method-name">uptodate?</span><span class="method-args">(new, old_list)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description">
<div class="method-source-code" id="uptodate-3F-source"> <pre class="ruby" data-language="ruby"># File lib/bundler/vendor/fileutils/lib/fileutils.rb, line 135
def uptodate?(new, old_list)
  return false unless File.exist?(new)
  new_time = File.mtime(new)
  old_list.each do |old|
    if File.exist?(old)
      return false unless new_time &gt; File.mtime(old)
    end
  end
  true
end</pre> </div> <p>Returns true if <code>new</code> is newer than all <code>old_list</code>. Non-existent files are older than any file.</p> <pre class="ruby" data-language="ruby">Bundler::FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \
    system 'make hello.o'
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core © 1993–2017 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library © contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>

				
			</div>
			<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-2572770204602497">
</amp-auto-ads>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="1992473792"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
